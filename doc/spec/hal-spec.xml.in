<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- CVSID: $Id$ -->
<!-- !DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" -->
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "/usr/share/sgml/docbook/xml-dtd-4.1.2-1.0-22.1/docbookx.dtd">

<!-- THIS FILE IS AUTOGENERATED FROM hal-spec.xml.in -->

<article id="index">
  <articleinfo>
    <title>HAL @VERSION@</title>
    <releaseinfo>Version @VERSION@</releaseinfo>
    <date>July 21, 2004</date> <!-- Update this manually -->
    <authorgroup>
      <author>
	<firstname>David</firstname>
	<surname>Zeuthen</surname>
	<affiliation>
	  <address>
	    <email>david@fubar.dk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </articleinfo>
  
  <sect1 id="introduction">
    <title>Introduction</title>
    <para>

      This document concerns the specification of HAL which is a piece of
      software that provides a view of the various hardware attached to
      a system. Though the name HAL is derived from Hardware Abstraction
      Layer, HAL in itself is not an abstraction layer in the traditional
      sense. The purpose of HAL is to give an up to date view of hardware,
      merge arbitrary metadata with metadata obtained from the hardware
      and provide hooks such that system-level and desktop session-level
      software can react to changes in the hardware configuration in order
      to maintain system policy.

    </para>
    <para>

      A device, in the context of the HAL, is identified by a unique
      id and a set of properties (key/value pairs).  This document
      specifies a set of known properties and gives them well-defined
      meaning. This enables applications and desktop environments to
      make a distinction between the different device objects and use
      the devices based on certain well-known properties.

    </para>
    <para>

      For instance, the <emphasis>info.category</emphasis> property
      specifies what the device is (such as a digital camera or an
      audio device), and the
      <emphasis>block.mount_point</emphasis> property
      specifies where in the filesystem a storage device is mounted. 
      In addition, the HAL provides generic device operations such as
      locking devices for exclusive access, or suspend/resume.

    </para>
    <para>

      In order to merge arbitrary metadata, HAL is concerned with so called 
      <emphasis>device information files</emphasis>.

      A device information file matches a subset of devices (from
      properties derived from the physical bus the device is on or
      what functionality the underlying kernel provides) and populates
      them with other, often well-defined, properties.

      Device information files are by no means a substitute for driver
      software, they are simply hints to the desktop environment /
      applications about what the device is, what it does and how it
      can be used. For example, a device information file can be used
      to specify that what the kernel sees only as a USB Mass Storage
      Device is in fact a digital camera or a MP3 player.

    </para>
    <para>

      The HAL is built upon D-BUS which is an IPC framework that, among
      other things, provides a system-wide message-bus that allows
      applications to talk to one another. Apart from D-BUS, HAL has
      no other major dependencies which, in theory, allows it to work
      on many UNIX-like systems. The major focus, initially, is
      systems running the Linux 2.6 kernel.

    </para>

    <sect2>
      <title>Version control</title>
      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Version</entry>
              <entry>Date</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0.1</entry>
              <entry>September 28, 2003</entry>
              <entry>Still important things missing. Released with version
                     0.1 of the implementation</entry>
            </row>
            <row>
              <entry>0.2</entry>
              <entry>December 22, 2003</entry>
              <entry>A major rewrite.</entry>
            </row>
            <row>
              <entry>@VERSION@</entry>
              <entry></entry>
              <entry>Current draft from CVS</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Acknowledgement</title>
      <para>

      Havoc Pennington's article
      <ulink url="http://www.ometer.com/hardware.html">&quot;Making Hardware Just Work&quot;</ulink> 
      motivated this specification. This specification would not exist
      without all the useful suggestions, comments and patches from the
      Free Desktop and HAL mailing lists.

      </para><para>

      All trademarks mentioned belong to their respective owners.

      </para>
    </sect2>

  </sect1>

  <sect1 id="overview"><title>Overview</title>

  <sect2 id="ov_halarch"><title>Architecture of HAL</title>
    <para>

      The HAL consists of a number of components as outlined in the diagram
      below

    </para>
    <para>
      <inlinegraphic fileref="hal-arch.png" format="PNG"/>
    </para>
    <para>

      Highlights

      <itemizedlist>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>HAL daemon</emphasis></para><para> 

          A system-wide daemon that maintains a persistent database of
          device objects. It is also responsible for merging
          information from the device info file repository and
          managing the life cycle of device objects. The HAL daemon
          also contains detection and monitoring code for standard
          busses (PCI, USB etc.) and devices. The HAL daemon notifies
	  system level components through callouts and session level
	  components using the D-BUS interface.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>HAL agents</emphasis></para><para> 

          The term <emphasis>HAL agent</emphasis> is used to
          characterize programs that is involved in the detection and
          monitoring of devices not supported directly by the HAL
          daemon.

          </para><para>

          Any program can be a HAL agent; all it means is that the
          program communicates with the HAL daemon using a specific
          interface.  Examples of use that come to mind are prototypes
          for supporting vendor or OEM specific busses/devices,
          integration of existing device detection/monitoring
          frameworks etc.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>Applications</emphasis></para><para> 

          This represents the end consumers of the HAL and comprises
          both applications that need to search for a device, but also
          (existing) device specific libraries and/or services that
          provide operations on devices. Specifically, the application
          or device library obtain the ''address'', (the special
          device file or other details) of the device through HAL but
          interact with the device through the kernel as normal.

          </para><para>

          In addition, this group include desktop environments such as
          GNOME or KDE. Specifically, using HAL, desktop environments
          may include session-daemons enforcing certain policies when
          the device database managed by the HAL daemon changes.

          </para><para>

          Such policies may include starting a photo management
          application when a camera is plugged in, assisting the user in
          finding driver software and device information files for a
          new device, displaying link information about network
          devices, mounting removable storage and so on.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>Callouts</emphasis></para><para> 

	  Callouts are invoked just after the HAL daemon have detected
	  a device, but just before desktop session level applications
	  are notified through the D-BUS interface. As such, callouts
	  can be used to maintain system-wide policy (that may be
	  specific to the particular OS) such as changing permissions
	  on device nodes, updating the systemwide /etc/fstab file or
	  configuring the networking subsystem.

        </para></listitem>

      </itemizedlist>
      </para>
      <para>

      The HAL uses D-BUS to provide a ''network API'' to both desktop
      applications and the aforementioned HAL agents. As D-BUS is
      designed to be language independent, potentially many languages
      / runtime systems will be able to easily access the services
      offered by HAL.

      </para><para>

      It is important to emphasize that both the HAL daemon and
      programs acting as HAL agents are responsible for both
      adding/creating device objects and monitoring devices. Examples
      of monitoring includes network device link detection, optical
      disc change detection, storage volume mount point detection etc.
      This is detailed in the following sections.

    </para>

  </sect2>

  <sect2 id="ov_scopearch"><title>Scope of HAL</title>
    <para>
      
      This section attempts to draw some line in the sand in terms of
      what HAL is supposed to do and not to do. First of all, HAL is
      concerned with

      <itemizedlist>
        <listitem><para>

        Maintaining a live list of device objects that correspond to
        the list maintained by the operating system kernel. This
        include bus specific information such as the PCI slot location
	or USB Vendor ID.

        </para></listitem> 
        <listitem><para>

        Merging class device information (derived from the hardware)
        into a device object.  For example, for an USB mouse HAL will
        merge well-defined properties describing the input-related
        capabilities of the mouse (e.g. how many buttons), and for
	optical discs HAL will merge information about the disc (e.g.
	is it a CD-R, DVD-RW etc.).

        </para></listitem> 
        <listitem><para>

        Merging information (produced by human beings) into a device
        from device information files.  This allows applications to
        think in terms of ''capabilities'' rather than relying on
        device class information derived from the hardware. For example,
	for MP3 players the set of audio formats can be merged.

        </para></listitem> 
        <listitem><para>

        Provide monitoring of detected devices in a way that doesn't
	disrupt normal device usage.

        </para></listitem> 
        <listitem><para>

        Provide ways for OS vendors to configure the operating system
	when new devices are detected by taking advantage of the metadata
	exported by HAL.

        </para></listitem> 
        <listitem><para>

        Providing a simple to use query/notification API for use in
        desktop applications.

        </para></listitem> 
      </itemizedlist>

      HAL is not concerned with

      <itemizedlist>
        <listitem><para>

        Device configuration; that is the task of loading an operating
        system driver, uploading firmware, mounting a disk or
        configure/initiate a network connection.  It should be noted,
        though, that HAL provides excellent infrastructure, callouts
        and D-BUS notifications, for doing some of these tasks.

        </para></listitem> 
        <listitem><para>

        Providing device-specific operations such as extracting
        pictures from a digital camera.  There already exists
        libraries and frameworks for dealing with hardware. The
        idea is to integrate HAL into already existing libraries/
	frameworks/applications.

        </para></listitem> 
      </itemizedlist>

      Specifically, HAL doesn't enforce any policy whatsoever, this
      is left for desktop environments and operating systems vendors to
      implement. See section TODO for further discussion.

      </para>
  </sect2>
  
  </sect1>

  <sect1>
    <title>Device Objects</title>
      <para>

      It is important to precisely define the term ''HAL device
      object'' - it is actually intended to mean two things:

      <itemizedlist>
        <listitem><para>

        A device as recognized by the USB, PCI etc. standards and treated as
        such by the operating system kernel and base OS. Note that a physical
	PCI board may appear as two PCI devices.

        </para></listitem>
        <listitem><para>

        Storage volumes (e.g. partitions on a storage device), optical
	discs and other first class objects in UNIX-like operating
	systems. While partitions are not real devices (they lend
	space on a real device such as a hard disk or an optical
	disc), they are on the same conceptual level as hard disks or
	optical discs.

        </para></listitem>
      </itemizedlist>

      Note there is not necessarily a one-to-one relationship between
      physical devices attached to a computer system and ''device objects''. 
      A multi-function device, which appears (and is marketed) to users 
      as a multi-function printer may show up as several device objects; e.g. 
      printer, scanner, fax and storage. 
      On the other hand, an USB keyboard with a scroll-wheel may appear as
      a single USB device with multiple USB interfaces.

      </para><para>

      HAL is not concerned with this duality of either one-to-one or
      many-to-one relationships between ''device objects'' and the actual iron
      constituting what users normally understand as a single device.

      </para><para>

      A device object consist of the following information

      <itemizedlist>
        <listitem><para>

          <emphasis>Unique Device ID (referred to as the UDI in the 
          following)</emphasis></para><para> 

          This is an identifier that is unique for a device object - that
          is, no other device object can have the same UDI at the same time.
          The UDI is computed from bus-specific information so it is unique
          across device insertions and when multiple instances of the same
          kind of device is plugged in. It is also independent of the 
	  physical slot the device is plugged into.

        </para></listitem>
        <listitem><para>

          <emphasis>Properties</emphasis></para><para> 

          Each device got a set of properties which are key/value pairs.
          The key is an ASCII string while the value can be one of several
          types

          <itemizedlist>
            <listitem><para>string - UTF8 string</para></listitem>
            <listitem><para>int32 - 32-bit signed integer</para></listitem>
            <listitem><para>bool - truth value</para></listitem>
            <listitem><para>double - IEEE754 double precision
                            floating point number</para></listitem>
          </itemizedlist>

        </para></listitem>
      </itemizedlist>

      Properties of a device object carry all the important information about
      a device object. This can be classified into three groups

      <itemizedlist>

	<listitem><para>Metadata - 
	                Information about how the devices are connected with
                        respect to each other (parent/child relationships) 
	                and what the device is and what it does
	</para></listitem>

        <listitem><para>Device specific information - 
                        vendor ID, product ID, disk serial numbers, 
	                number of buttons on a mouse, formats accepted
	                by a mp3 player, connection structure etc.</para></listitem>

        <listitem><para>Usage specific information - 
	                Network link status, special device file, 
                        mount location etc.</para></listitem>
      </itemizedlist>

      The first category is determined by HAL itself, the next is
      merged from either the hardware itself or device information
      files and the last is intercepted by monitoring the operating
      system.

      This specification is concerned with precisely defining several 
      properties; see 
      <xref linkend="device-properties"/> and onwards for more
      information. 

      As a complement to device properties, HAL also provides 
      <emphasis>conditions</emphasis> on HAL device objects. Conditions
      are used to relay events that are happening on devices which are
      not easily expressed in properties. This includes events such as
      ''processor is overheating'' or ''block device unmounted''.

      The fundamental idea about HAL is that all ''interesting'' information
      that a desktop application would be using can be obtained by HAL.

      </para><para>

      Below is a screenshot of a device manager application communicating
      with the HAL daemon and displaying the devices. The shown properties
      are for a device representing a harddisk

      </para><para>
        <inlinegraphic fileref="hal-devices1.png" format="PNG"/>
      </para><para>

      </para>
  </sect1>

  <sect1>
    <title>D-BUS Network API</title> <para> 

      The HAL daemon is a system-wide process that keeps track of a
      number of device objects. It communicates with the operating
      system and intercepts hotplug events as devices are plugged in
      and removed.
      The daemon is also responsible for providing services to
      applications that wants to locate devices and perform
      generic operations them such as obtaining exclusive access.
      Non-generic operations, such as obtaining pictures from a camera
      device, is outside the scope of the HAL daemon; see <xref
      linkend="using-devices"/> for more information.

      </para><para>

      Note that the HAL daemon has the concept of a Global Device List
      (GDL in the following) that contains the devices that the
      clients can search and subscribe on changes to. 

      When a device have been detected, either from inside the HAL daemon 
      or from an HAL agent, devices are not initially in the GDL; instead, 
      they are added later when a number of properties have been merged.

      </para>

      <sect2><title>Interface org.freedesktop.Hal.Manager</title>

      <para> 

      Using D-BUS terminology, the HAL daemon provides the D-BUS service
      org.freedesktop.Hal. This service offers a D-BUS object at a 
      well-known location /org/freedesktop/Hal/Manager. This object
      offers a D-BUS interface, org.freedesktop.Hal.Manager, for 
      querying device objects with the following methods:
      </para>

<programlisting>
# Return a list of all devices in the GDL
#
# @return                       List of UDI's
#
array{string} GetAllDevices()

# Determine if a device with a given Unique Device Id exists in the GDL
#
# @param  udi                   Device UDI, for example '/org/freedesktop/Hal/devices/pci_8086_7111'
# @return                       TRUE iff the device with the given UDI exists
#
bool DeviceExists(string udi)

# Find the set of devices in the GDL that has a given property matching
# a given value
#
# @param  key                   Key, for example 'block.fstype'
# @param  value                 Value, for example 'ext3'
# @return                       List of UDI's
#
array{string} FindDeviceStringMatch(string key, string value)

# Find the set of devices in the GDL that has a given capability
#
# @param  capability            Capability, for example 'volume'
# @return                       List of UDI's
#
array{string} FindDeviceByCapability(string capability)
  
</programlisting>

      <para>

      This object also emits the following signals on the
      org.freedesktop.Hal.Manager interface that applications can
      subscribe to using D-BUS:

<programlisting>

# Notification that a new device have been added to the GDL
#
# @param  udi                   Unique Device Id
#
void DeviceAdded(string udi)

# Notification that a new device have been removed from the GDL. The
# application cannot use this UDI anymore.
#
# @param  udi                   Unique Device Id
#
void DeviceRemoved(string udi)

# Notification that a device in the GDL have got a new capability. Note that
# this is emitted even though the device already had the old capability
#
# @param  udi                   Unique Device Id
#
void NewCapability(string udi, string capability)

</programlisting>

      </para>
      </sect2>

      <sect2><title>Interface org.freedesktop.Hal.Device</title><para>

      Applications use the Manager interface to locate the device
      objects they are interested in. When a device object (which is
      really a D-BUS object, note that the UDI is the objects object_path)
      is obtained, the HAL daemon provides the
      org.freedesktop.Hal.Device interface with the following methods

      </para>

<programlisting>

# Set property
#
# @param  key                   Property to set
# @param  value                 Value to set
# @raises                       org.freedesktop.Hal.(NoSuchDevice|TypeMismatch)
#
void SetProperty(string key, any value)
void SetPropertyString(string key, string value)
void SetPropertyInteger(string key, int32 value)
void SetPropertyBoolean(string key, bool value)
void SetPropertyDouble(string key, double value)

# Get property
#
# @param  key                   Property to get
# @return                       The value of the property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty|TypeMismatch)
#
any GetProperty(string key)
string GetPropertyString(string key)
int32 GetPropertyInteger(string key)
bool GetPropertyBoolean(string key)
double GetPropertyDouble(string key)

# Get all properties
#
# @return                       Dictionary from key to value
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
map{string, any} GetAllProperties()

  
# Remove a property
#
# @param  key                   Property to remove
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty)
#
void RemoveProperty(string key)

# Get the type of a property
#
# @param  key                   Property
# @return                       D-BUS type of property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty)
#
int32 GetPropertyType(string key)

# Determine if a property exists
#
# @param  key                   Property
# @return                       TRUE iff the property exists
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool PropertyExists(string key)

# Add a capability to a device. Note that this will trigger a NewCapability
# signal to all client applications subscribing to signals from the Manager
# interface.
#
# @param  capability            Capability, e.g. 'net.ethernet'
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void AddCapability(string capability)

# Determine if a device got a given capability
#
# @param  capability            Capability, e.g. 'video.vga'
# @return                       TRUE iff the device got the given capability
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool QueryCapability(string capability)
</programlisting>

      <para>

      The device objects also emits the following signals on the
      org.freedesktop.Hal interface that applications can subscribe to 
      using D-BUS

      </para>
<programlisting>
# Notification that property have been added
#
# @param  key                   Property
#
void PropertyAdded(string key)

# Notification that property have been removed
#
# @param  key                   Property
#
void PropertyRemoved(string key)

# Notification that property have changed value
#
# @param  key                   Property
#
void PropertyChanged(string key)
</programlisting>
      <para>

      Note that D-BUS supports that applications can opt to receive
      signals for only a subset of the devices available.

      </para>

      </sect2>

      <sect2><title>Interface org.freedesktop.Hal.AgentManager</title><para>

      The API described above is available to all applications. There is 
      an additional D-BUS interface on the /org/freedesktop/Hal/Manager
      object called org.freedesktop.Hal.AgentManager which is only available
      for processes running with administrative privileges. 
      </para>

<programlisting>

# Create a new device object not in the GDL (ie. hidden from 
# applications). This object can be obtained using the given UDI as
# as the D-BUS object reference. 
#
# The object implements the org.freedesktop.Hal.Device interface
#
# @return                       Temporary UDI for new device object
#
string NewDevice()

# When a device have been built, an application can add it to the GDL.
#
# A side-effect of this call, is that the Manager object will emit the
# signal DeviceAdded.
# 
# @param  tempUdi               Temporary UDI as obtained from the NewDevice call
# @param  newUdi                New UDI to use.
# @raises                       org.freedesktop.Hal.(NoSuchDevice|UdiInUse)
#
void CommitToGDL(string tempUdi, string newUdi)

# Remove a device object. 
#
# Depending on the info.persistent property, the device may not be removed but
# rather acquire the property info.not_available with value true.
#
# @param  udi                   UDI of device
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void Remove(string udi)

# Merge all properties from one device to another device.
#
# If the source device got any capabilities, then the target device
# will acquire these capabilities and a NewCapability signal will be
# emitted for the target device for every capability in the source
# device.
#
# @param  targetUdi             UDI of device to receive properties
# @param  sourceUdi             UDI of device to copy properties from
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void MergeProperties(string targetUdi, string sourceUdi)

# Checks that all properties where keys, starting with a given value
# (namespace), of the first device is present in the second device and that
# they got the same value and type. 
#
# Note that the other inclusion isn't tested, so there could be
# properties (from the given namespace) in the second device not present
# in the first device.
#
# @param  udi1                  UDI of device 1
# @param  udi2                  UDI of device 2
# @param  namespace             Namespace used for matching, e.g. 'usb'
# @return                       TRUE if, and only if, all properties starting
#                               with the namespace parameter from udi1 is
#                               in udi2 and assume the same value
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool DeviceMatches(string udi1, string udi2, string namespace)

</programlisting>
      <para>
      HAL Agents uses the org.freedesktop.Hal.AgentManager API when 
      discovering devices either through detection, handling hotplug
      events or through some other way.
      </para>

      </sect2>

  </sect1>

  <sect1 id="using-devices">
    <title>Using devices</title>
    <para>
    One of the goals of the HAL is to provide easy access to devices on
    a system. This includes obtaining device specific information, such
    as CPU frequency, and invoking device specific methods such as
    getting the pictures on a camera or changing the volume on a sound
    device.

    </para><para>

    While the HAL daemon provides generic operations that apply to all
    devices (though some may be no-ops) and provide some level of monitoring
    for well-know class devices (such as networking devices), it is not
    concerned with providing non-generic device operations. 

    </para><para>

    The architecture of the HAL allows a number of ways of dealing with
    specific device information and operations

    <itemizedlist>
      <listitem><para>
        <emphasis>Out-of-process D-BUS Service</emphasis></para><para> 
        For example, one could write a volume manager that manages the
        different storage devices present on the system and mount the
        partitions/volumes available on those into the filesystem 
        according to certain rules. 
        The volume manager would run as a daemon monitoring the device list
        of the HAL daemon and act appropriately when devices having 
        Storage and StorageVolume in the Capabilitites property appear and
        disappear. 

        </para><para>

        The volume manager could also offer an operation for writing
        ISO images to e.g. CD-R devices through a D-BUS interface
        on HAL device object. In this scenario, a desktop file manager
        would use the HAL daemon to query for the HAL device object
        that is a CD recorder and pass the object reference to the
        D-BUS service offered by the volume manager.
      </para></listitem>
      <listitem><para>
        <emphasis>In-process library</emphasis></para><para> 

        Another example is device objects having capability
        camera. One could use an existing library, such as libgphoto2,
        and make wrapper functions such that the application
        programmer simple passes the HAL UDI to the library. The
        library would then, via D-BUS, acquire the bus-specific
        information required from the HAL daemon, and then interact
        with the device.

      </para></listitem>
    </itemizedlist>

    Note that there are other ways of dealing with device-specific
    operations - this list is not exhaustive.
    
    </para>
  </sect1>

  <sect1 id="capabilties">
     <title>Capabilities</title>
     <para>

     As previously mentioned the capabilities of a device specify what
     the device does. For instance, a CompactFlash card reader can be
     thought of as a camera, a handheld music device and removable
     storage.

     </para><para>

     HAL itself, assigns capabilities on device detection time by
     inspecting the device class (if available, it depends on the bus
     type) and looking at information from the operating system (most
     OS'es has a concept of device classes). At this time the category
     is also determined by selecting the most prominent
     capability. However, both capabilities and category can be
     overridden by either device information files or a desktop
     environment policy daemon. This gives maximum flexibility, while
     maintaining a base level of capability detection. 

     </para><para>

     Note that, for instance, a number of USB devices doesn't advertise
     anything in their device class, so a repository of device
     information files coupled with an interactive dialog (provided by a
     desktop environment daemon) asking the user what he just plugged
     in, will probably yield the best experience for users. Incidently,
     this is how certain non-free operating systems appear to handle
     hardware.

     </para><para>

     Returning to the example of the card reader, this might just
     happen to be a digital camera with the only interface being a
     card reader - HAL, or the base OS, wouldn't be able to tell the
     difference - it's just looks like a storage device. So, to handle
     hardware well to meet the expectation of the users, device
     information files and desktop environment policy daemons need to
     be available on top of HAL (notably, the desktop environment
     daemon might look at the files on the device to infer whether
     it's music, pictures or something else) and adjust the capabilities
     and category of certain devices.

     </para><para>

     Finally, what a given capability means, needs to be precisely
     defined. The idea of HAL is that existing device capability
     specific libraries (such as libghoto2), would advertise what kind
     of HAL capabilities they are able to handle. As this happens over
     time, this specification will grow to precisely define what a
     device with a given capability is supposed to do and what
     library, or service, the application programmer can use to access
     the device. At some point in time, we may define an uniform
     in-process extension framework akin to e.g. OpenGL extensions for
     accessing said libraries and services.
     
     </para><para>

     Having a capability also means that part of the property
     namespace, prefixed with the capability name, can (but it's not a
     requirement) be populated with more specific information about
     the capability. Virtual devices will not have any capabilities
     assigned to them.

     </para><para>

     The following table define the capabilities supported in HAL at
     the time of writing.

     </para>
     <informaltable>
       <tgroup cols="2">
         <thead>
           <row>
             <entry>Capability</entry>
             <entry>Description</entry>
             <entry>Example Devices</entry>
           </row>
         </thead>
         <tbody>

           <row>
             <entry>input</entry>
             <entry>A human input device</entry>
             <entry>Keyboard, Mouse</entry>
           </row>
           <row>
             <entry>input.mouse</entry>
             <entry>A pointing device, such as a mouse</entry>
             <entry></entry>
           </row>
           <row>
             <entry>input.keyboard</entry>
             <entry>A keyboard</entry>
             <entry></entry>
           </row>

           <row>
             <entry>storage</entry>
             <entry>A storage device</entry>
             <entry>Harddisk, USB storage</entry>
           </row>
           <row>
             <entry>storage.removable</entry>
             <entry>A storage device with removable media</entry>
             <entry>CD-ROM, CR-R, Floppy, DVD, Zip-drive</entry>
           </row>

           <row>
             <entry>storage_controller</entry>
             <entry>A device for controlling storage devices</entry>
             <entry>USB storage, IDE, SCSI, RAID controller</entry>
           </row>
           <row>
             <entry>storage_controller.ide</entry>
             <entry>A device for controlling IDE storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.scsi</entry>
             <entry>A device for controlling SCSI storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.floppy</entry>
             <entry>A device for controlling floppy storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.raid</entry>
             <entry>A device for controlling RAID storage devices</entry>
             <entry></entry>
           </row>

           <row>
             <entry>bridge</entry>
             <entry>The device is bridging one bus to another</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>bridge.cardbus</entry>
             <entry>PCI to CardBus bridge</entry>
             <entry>The standard interface for PCMCIA formfactor cards</entry>
           </row>
           <row>
             <entry>bridge.pcmcia</entry>
             <entry>PCI to PCMCIA bridge</entry>
             <entry>Used in old laptops, not very common anymore</entry>
           </row>
           <row>
             <entry>bridge.pci</entry>
             <entry>PCI to PCI bridge</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>bridge.host</entry>
             <entry>PCI host bridge</entry>
             <entry>Found in many PC's today</entry>
           </row>

           <row>
             <entry>video</entry>
             <entry>Video adaptor</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>video.vga</entry>
             <entry>VGA comptible video adaptor</entry>
             <entry>Almost all graphics adaptors in the market</entry>
           </row>

           <row>
             <entry>multimedia</entry>
             <entry>Multimedia device</entry>
             <entry>Sound cards etc.</entry>
           </row>
           <row>
             <entry>multimedia.audio</entry>
             <entry>Sound card</entry>
             <entry></entry>
           </row>

           <row>
             <entry>comm</entry>
             <entry>Communication adaptors</entry>
             <entry>Serial and parallel port adaptors</entry>
           </row>
           <row>
             <entry>comm.serial</entry>
             <entry>Serial port adaptor</entry>
             <entry></entry>
           </row>
           <row>
             <entry>comm.parallel</entry>
             <entry>Parallel port adaptor</entry>
             <entry></entry>
           </row>

           <row>
             <entry>modem</entry>
             <entry>A PSTN modem</entry>
             <entry></entry>
           </row>
           <row>
             <entry>modem.hayes</entry>
             <entry>A PSTN modem compatible with the Hayes command protocol</entry>
             <entry></entry>
           </row>

           <row>
             <entry>serial_controller</entry>
             <entry>Modern serial communication controllers</entry>
             <entry>USB, IEEE1394 (Firewire, i.Link)</entry>
           </row>
           <row>
             <entry>serial_controller.ieee1394</entry>
             <entry>IEEE1394 controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>serial_controller.usb</entry>
             <entry>USB controller</entry>
             <entry></entry>
           </row>


           <row>
             <entry>net</entry>
             <entry>Networking controller</entry>
             <entry>Ethernet, ATM etc. controllers</entry>
           </row>
           <row>
             <entry>net.ethernet</entry>
             <entry>Ethernet controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>net.atm</entry>
             <entry>ATM controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>net.tokenring</entry>
             <entry>Token Ring controller</entry>
             <entry></entry>
           </row>

           <row>
             <entry>printer</entry>
             <entry>Printer</entry>
             <entry></entry>
           </row>

           <row>
             <entry>hub</entry>
             <entry>A device for multiplexing a number of devices of same bus-type on a single port </entry>
             <entry>USB hub</entry>
           </row>

           <row>
             <entry>bluetooth_adaptor</entry>
             <entry>Bluetooth adaptor</entry>
             <entry></entry>
           </row>

           <row>
             <entry>block</entry>
             <entry>Device represents a block device</entry>
             <entry></entry>
           </row>

           <row>
             <entry>volume</entry>
             <entry>Device represents a partition of a block device that can 
             be mounted in the filesystem</entry>
             <entry></entry>
           </row>

           <row>
             <entry>camera</entry>
             <entry>Device is a camera where still pictures can be extracted from</entry>
             <entry></entry>
           </row>

         </tbody>
       </tgroup>
     </informaltable>
     <para>

     As evident, most of the capabilities in the above list is derived
     directly from USB and PCI classes (the careful reader will even
     note that not all classes from the USB and PCI standards are
     mentioned), and as such, are not very interesting to desktop
     applications.

     </para><para>

     However, if HAL becomes adopted by applications, new and
     interesting capabilities (for example <emphasis>pda</emphasis>,
     <emphasis>camera</emphasis> or
     <emphasis>handheld_music_player</emphasis>), based on what the
     device is used for, can begin to appear.

     </para>
  </sect1>

  <sect1 id="device-properties">
    <title>Properties of a device</title>

    <para>
      Properties are arranged in a namespaces using . (dot) as a separator
      and are key/value pairs. The value may assume different types; currently
      int32, double, bool and UTF8 strings are supported. The key of a property
      is always an ASCII string without any whitespace.
    </para>

    <sect2 id="device-properties-info">
      <title>info namespace</title>
      <para>
      The info namespace of the properties can be considered meta-data about
      a device. The following properties are defined:
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>info.bus (string)</entry>
              <entry>pci, usb, ide_host, ide, block, usb, usbif, scsi_host, scsi_device</entry>
              <entry>Yes</entry>
              <entry>Describes what ''physical'' bus the device is on</entry>
            </row>
            <row>
              <entry>info.udi (string)</entry>
              <entry>example: /org/freedesktop/Hal/devices/block_22_0</entry>
              <entry>Yes</entry>
              <entry>The HAL unique device id</entry>
            </row>
            <row>
              <entry>info.persistent (bool)</entry>
              <entry></entry>
              <entry>No, but required if info.not_available is set to true</entry>
              <entry>If this property is set, the device will remain in the
                     the GDL even if the device is unplugged</entry>
            </row>
            <row>
              <entry>info.not_available (bool)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>The device is currently not available (it may be unplugged
                     or powered down)</entry>
            </row>
            <row>
              <entry>info.capabilities (string)</entry>
              <entry>example: block storage storage.removable</entry>
              <entry>No</entry>
              <entry>A white-space separated list of capabilities describing what the devices does</entry>
            </row>
            <row>
              <entry>info.category (string)</entry>
              <entry>example: storage.removable</entry>
              <entry>No</entry>
              <entry>The prominent capability describing what the device is</entry>
            </row>
            <row>
              <entry>info.product (string)</entry>
              <entry>examples: SleekKeyboard, MouseMan 2003, Volume, LS-120 SLIM3 00 UHD Floppy</entry>
              <entry>No</entry>
              <entry>The name of the product or class, the device is an instance of</entry>
            </row>
            <row>
              <entry>info.vendor (string)</entry>
              <entry>example: Logitch</entry>
              <entry>No</entry>
              <entry>The name of the vendor of the device</entry>
            </row>
            <row>
              <entry>info.parent (string)</entry>
              <entry>example: /org/freedesktop/Hal/devices/ide_1_0</entry>
              <entry>Yes, for all non-root devices</entry>
              <entry>The UDI of the parent of the device, connection-wise; 
                     see screenshots of device manager</entry>
            </row>
            <row>
              <entry>info.virtual (bool)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>If available and set to true, it means that the HAL 
                     device object doesn't represent a device per se, and
                     as such should be ignored </entry>
            </row>
            <row>
              <entry>info.physical_device (string)</entry>
              <entry></entry>
              <entry>Must only be set if, and only if, info.virtual is true</entry>
              <entry>The non-virtual device that this device is created for.</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>

      <para>

      The info.parent property is very significant - for example, it's
      what allows applications to associate a volume with a
      device. Consider the following setup of devices

      </para>
      <para>
        <inlinegraphic fileref="hal-volume-to-device.png" format="PNG"/>
      </para>
      <para>

      Now, the ''CF Reader'' USB device is an ancestor to the the
      volume that has highlight. Desktop environments can detect this
      by traversing from the volume device through parents to find the
      USB device and either merge more information (such as the
      capability camera) into the USB device object or extract the
      capability (a device information file might have merged the
      capability camera) and act accordingly. Optionally, the DE can
      make the USB device persistent by setting the property
      info.persistent to true.

      </para><para>

      Indeed, this very use-case is one of the reasons that HAL tracks
      information about volumes (FIXME: HAL should, in a later version,
      directly support a property in info. that points to the actual
      device).

      </para>
    </sect2>


    <sect2 id="device-properties-linux">
      <title>linux namespace</title>
      <para>
      This namespace is used to store Linux-specific information about the
      device and is such only required on Linux.
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>linux.sysfs_path (string)</entry>
              <entry>examples: /sys/block/sda/sda1, /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0</entry>
              <entry>Yes</entry>
              <entry>A fully-qualified path into the sysfs filesystem for the
              physical device</entry>
            </row>
            <row>
              <entry>linux.sysfs_path_device (string)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Normally this property assumes the same value as 
              linux.sysfs_path, however for some devices it assumes an
              alternate location in the sysfs filesystem. It is used
              internally in HAL</entry>
            </row>
            <row>
              <entry>linux.driver (string)</entry>
              <entry>examples: agpgart-intel, yenta_cardbus, usb, hub, hid</entry>
              <entry>No</entry>
              <entry>Name of the driver bound to this device</entry>
            </row>
            <row>
              <entry>linux.sysfs_bus_id (string)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>The part of linux.sysfs_path after last /. Used 
              internally in HAL</entry>
            </row>
            <row>
              <entry>linux.kernel_devname (string)</entry>
              <entry>example: usb-0000:00:07.2-1.2</entry>
              <entry>No</entry>
              <entry>A name specifically used by the kernel to identify the
              device. Used internally in HAL</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect2>


    <sect2 id="device-properties-pci">
      <title>pci namespace</title>
      <para>
      If a device is on a PCI bus, then these properties are available:
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>pci.device_class (int)</entry>
              <entry>example: 3</entry>
              <entry>Yes</entry>
              <entry>Device class</entry>
            </row>
            <row>
              <entry>pci.device_subclass (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device subclass</entry>
            </row>
            <row>
              <entry>pci.device_protocol (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device protocol</entry>
            </row>
            <row>
              <entry>pci.product_id (int)</entry>
              <entry>example: 0x4c4d</entry>
              <entry>Yes</entry>
              <entry>Product ID</entry>
            </row>
            <row>
              <entry>pci.vendor_id (int)</entry>
              <entry>example: 0x1002</entry>
              <entry>Yes</entry>
              <entry>Vendor ID</entry>
            </row>
            <row>
              <entry>pci.subsys_product_id (int)</entry>
              <entry>example: 0x009e</entry>
              <entry>Yes</entry>
              <entry>Subsystem product id</entry>
            </row>
            <row>
              <entry>pci.subsys_vendor_id (int)</entry>
              <entry>example: 0x1028</entry>
              <entry>Yes</entry>
              <entry>Subsystem vendor id</entry>
            </row>
            <row>
              <entry>pci.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:01/0000:01:00.0</entry>
              <entry>Yes</entry>
              <entry>Equals linux.sysfs_path</entry>
            </row>
            <row>
              <entry>pci.product (string)</entry>
              <entry>Rage Mobility P/M AGP 2x</entry>
              <entry>No</entry>
              <entry>Name of the product per the PCI database</entry>
            </row>
            <row>
              <entry>pci.vendor (string)</entry>
              <entry>ATI Technologies Inc</entry>
              <entry>No</entry>
              <entry>Name of the vendor per the PCI database</entry>
            </row>
            <row>
              <entry>pci.subsys_product (string)</entry>
              <entry>Inspiron 7500</entry>
              <entry>No</entry>
              <entry>Name of the subsystem product per the PCI database</entry>
            </row>
            <row>
              <entry>pci.subsys_vendor (string)</entry>
              <entry>Dell Computer Corporation</entry>
              <entry>No</entry>
              <entry>Name of the subsystem vendor per the PCI database</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      (FIXME: Some key PCI information (bus, slot, port, function
      etc.) is missing here, but that is easy to add once someone
      request it)

      </para>
    </sect2>


    <sect2 id="device-properties-usb">
      <title>usb, usbif namespace</title>
      <para>

      If a device is on a USB bus, then these properties
      areavailable. Note that USB devices and the associated USB
      interfaces are split onto different devices (and info.bus
      values). An USB interface is always a child of the corresponding
      USB device.

      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>usb.bus_number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The USB bus the device is attached to</entry>
            </row>
            <row>
              <entry>usb.configuration_value (int) </entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The current configuration the USB device is in,
              starting from 1</entry>
            </row>
            <row>
              <entry>usb.num_configurations (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of configurations this USB device 
              can assume</entry>
            </row>
            <row>
              <entry>usb.device_class (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device class</entry>
            </row>
            <row>
              <entry>usb.device_subclass (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device sub class</entry>
            </row>
            <row>
              <entry>usb.device_protocol (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device protocol</entry>
            </row>

            <row>
              <entry>usb.is_self_powered (bool)</entry>
              <entry>example: false</entry>
              <entry>Yes</entry>
              <entry>The device, in this configuration, is self powered</entry>
            </row>
            <row>
              <entry>usb.can_wake_up (bool)</entry>
              <entry>example: true</entry>
              <entry>Yes</entry>
              <entry>The device, in this configuration, can wake up</entry>
            </row>

            <row>
              <entry>usb.max_power (int)</entry>
              <entry>example: 98</entry>
              <entry>Yes</entry>
              <entry>Max power drain of device, in mA</entry>
            </row>
            <row>
              <entry>usb.num_interfaces (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of interfaces in current configuration</entry>
            </row>
            <row>
              <entry>usb.num_ports (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Number of ports on a hub. Zero for non-hubs</entry>
            </row>
            <row>
              <entry>usb.port_number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The port number on the parent hub, starting from 1</entry>
            </row>
            <row>
              <entry>usb.speed_bcd (int)</entry>
              <entry>examples: 0x00150, 0x01200, 0x48000</entry>
              <entry>Yes</entry>
              <entry>Speed of device in BCD</entry>
            </row>
            <row>
              <entry>usb.version_bcd (int)</entry>
              <entry>examples: 0x0100, 0x0110, 0x0200</entry>
              <entry>Yes</entry>
              <entry>USB version of device in BCD</entry>
            </row>
            <row>
              <entry>usb.level_number (int)</entry>
              <entry>example: 2</entry>
              <entry>Yes</entry>
              <entry>Depth in physical USB tree, where the virtual root hub
              is at depth 0</entry>
            </row>
            <row>
              <entry>usb.linux.device_number (string)</entry>
              <entry>example: 19</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Device number assigned by the Linux kernel</entry>
            </row>
            <row>
              <entry>usb.linux.parent_number (string)</entry>
              <entry>example: 19</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Device number of parent device as assigned by the
              Linux kernel</entry>
            </row>
            <row>
              <entry>usb.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Equal to linux.sysfs_path</entry>
            </row>
            <row>
              <entry>usb.product_id (int)</entry>
              <entry>example: 0x3005</entry>
              <entry>Yes</entry>
              <entry>USB product ID</entry>
            </row>
            <row>
              <entry>usb.vendor_id (int)</entry>
              <entry>example: 0x04b3</entry>
              <entry>Yes</entry>
              <entry>USB vendor ID</entry>
            </row>
            <row>
              <entry>usb.device_revision_bcd (int)</entry>
              <entry>example: 0x0100</entry>
              <entry>Yes</entry>
              <entry>Revision number of device, in BCD</entry>
            </row>
            <row>
              <entry>usb.serial (string)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>A string uniquely identifying the instance 
              of the device; ie. it will be different for two, otherwise
              identical devices</entry>
            </row>
            <row>
              <entry>usb.product (string)</entry>
              <entry>example: IBM USB HUB KEYBOARD</entry>
              <entry>No</entry>
              <entry>Name of the product per the USB database</entry>
            </row>
            <row>
              <entry>usb.vendor (string)</entry>
              <entry>example: IBM Corp.</entry>
              <entry>No</entry>
              <entry>Name of the vendor per the USB database</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      And these are the properties for an USB interface

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>usbif.device_product_id (int)</entry>
              <entry>example: 0x3005</entry>
              <entry>Yes</entry>
              <entry>USB product ID of the device this interface
              belongs to</entry>
            </row>
            <row>
              <entry>usbif.device_vendor_id (int)</entry>
              <entry>example: 0x04b3</entry>
              <entry>Yes</entry>
              <entry>USB vendor ID of the device this interface
              belongs to</entry>
            </row>
            <row>
              <entry>usbif.interface_class (int)</entry>
              <entry>example: 0x03</entry>
              <entry>Yes</entry>
              <entry>Class of this interface</entry>
            </row>
            <row>
              <entry>usbif.interface_subclass (int)</entry>
              <entry>example: 0x01</entry>
              <entry>Yes</entry>
              <entry>Subclass of this interface</entry>
            </row>
            <row>
              <entry>usbif.interface_protocol (int)</entry>
              <entry>example: 0x01</entry>
              <entry>Yes</entry>
              <entry>Protocol for this interface</entry>
            </row>
            <row>
              <entry>usbif.number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of this interface</entry>
            </row>
            <row>
              <entry>usbif.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1/1-1.1:1.0</entry>
              <entry>Yes</entry>
              <entry>Equals linux.sysfs_path</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect2>


    <sect2 id="device-properties-ide">
      <title>ide, ide_host namespace</title>
      <para>

      These namespaces are used to characterise IDE host adaptors and IDE
      channels. In a standard PC, there are usually two IDE host
      adaptors each with two channels (master and slave). Normally, the
      device chain looks like
     
      </para> 
      <programlisting>
      storage_controller.ide -&gt; ide_host -&gt; ide -&gt; block -&gt block
      </programlisting>
      <para>

      where the first device represents the IDE controller on the motherboard
      while the last device represents a partition on a (slave or master) 
      IDE disk, and the device before that represent, e.g. a physical
      harddisk. Notably, the first block device will have capability storage
      (maybe even storage.removable) and the last block device will have
      capability volume.

      </para><para>

      (FIXME: Is this the right terminology to use?)

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ide_host.number (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>A unique number identifying the IDE host adaptor</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ide.channel (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Corresponds to ide_host.number of the ide_host device
              that is the parent of this device</entry>
            </row>
            <row>
              <entry>ide.sub_channel (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Identifies the IDE channel of this interface</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>

      </para>
    </sect2>

    <sect2 id="device-properties-scsi">
      <title>scsi_host, scsi_device namespace</title>
      <para>
      (FIXME: Need to populate these namespaces with some interesting
      information such as SCSI LUN address and so on.)
      </para>
    </sect2>

    <sect2 id="device-properties-input">
      <title>input namespace</title>
      <para>
      
      This namespace is concerned with input devices such as
      keyboards, pointing devices and game controllers.  If a device
      has the capability input (USB HID devices normally do), then the
      folling properties are available
      
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>input.absolute (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device is capable of giving absolute device
              coordinates when motion is detected (such as a tablet or
              game controller)</entry>
            </row>
            <row>
              <entry>input.absolute.x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.z (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rx (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.ry (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rz (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rz (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.throttle (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rudder (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.wheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.gas (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.brake (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat0x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat0y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat1x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat1y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat2x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat2y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.pressure (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.distance (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.tilt_x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.tilt_y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.relative (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device is capable of giving relate device
              coordinates when motion is detected (such as a mouse)</entry>
            </row>
            <row>
              <entry>input.relative.x (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.y (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.z (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.hwheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.dial (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.wheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.led (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device has LED indicators that can be on or off
              </entry>
            </row>
            <row>
              <entry>input.led.numlock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.capslock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.scrolllock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.compose (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.kana (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.sleep (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.suspend (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.mute (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.max (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.force_feedback (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry></entry>
            </row>

            <row>
              <entry>input.key (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device has keys the user can press</entry>
            </row>
            <row>
              <entry>input.repeat (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device sends repeat keypresses if a key is pressed
              down</entry>
            </row>
            <row>
              <entry>input.sound (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device can emit sounds</entry>
            </row>

            <row>
              <entry>input.linux.phys (string)</entry>
              <entry>example: usb-0000:00:07.2-1.2</entry>
              <entry>Yes (Linux only)</entry>
              <entry>The name of the physical device as used by the kernel.
              Used internally by HAL; see also linux.kernel_devname</entry>
            </row>

            <row>
              <entry>input.linux.handlers (string)</entry>
              <entry>examples: mouse1, kbd</entry>
              <entry>Yes (Linux only)</entry>
              <entry>The Linux input handlers for this device</entry>
            </row>
            <row>
              <entry>input.linux.keybit (string)</entry>
              <entry>examples: 10000 7f ffe7207a c14057ff ffbeffdf ffffffff ffffffff fffffffe, f0000 0 0 0 0 0 0 0 0</entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>

            <row>
              <entry>input.linux.evbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.ledbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.relbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.absbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      (FIXME: Is this too linux specific?)

      </para>
    </sect2>


    <sect2 id="device-properties-block">
      <title>block namespace</title>
      <para>

      A block device is either a storage device (such as a harddisk, floppy
      or optical driver) or a partition on a storage, ie. a volume.

      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>block.block_size (int)</entry>
              <entry>example: 512</entry>
              <entry>Yes</entry>
              <entry>Size in octects of every block on the device</entry>
            </row>
            <row>
              <entry>block.size (int)</entry>
              <entry>example: 15584</entry>
              <entry>Yes</entry>
              <entry>Size of storage area, in blocks</entry>
            </row>
            <row>
              <entry>block.start (int)</entry>
              <entry>example: 32</entry>
              <entry>Yes</entry>
              <entry>Linear offset, in blocks, where the storage area
              starts</entry>
            </row>
            <row>
              <entry>block.major (int)</entry>
              <entry>example: 8</entry>
              <entry>Yes</entry>
              <entry>Major number of special file to interact with the 
              device</entry>
            </row>
            <row>
              <entry>block.minor (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Minor number of special file to interact with the 
              device</entry>
            </row>
            <row>
              <entry>block.is_volume (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>True iff the block device is a volume that can be mounted 
              into the file system</entry>
            </row>
            <row>
              <entry>block.is_mounted (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>True iff the block device is currently mounted in the
              file system</entry>
            </row>

            <row>
              <entry>block.device (string)</entry>
              <entry>example: /udev/sda1 </entry>
              <entry>Mandatory if block.is_volume is true</entry>
              <entry></entry>
            </row>

            <row>
              <entry>block.fs_type (string)</entry>
              <entry>example: vfat </entry>
              <entry>Mandatory if block.is_mounted is true</entry>
              <entry></entry>
            </row>
            <row>
              <entry>block.mount_point (string)</entry>
              <entry>example: /mnt/cfreader </entry>
              <entry>Mandatory if block.is_mounted is true</entry>
              <entry></entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      blabla

      </para>
    </sect2>


    <sect2 id="device-properties-net">
      <title>net, net.ethernet namespace</title>
      <para>
      The net and net.ethernet namespace contains information about
      (logicial) network devices and only applies to devices with
      capability net and/or net.ethernet.
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>net.arp_proto_hw_id (int)</entry>
              <entry>examples: 1 (ethernet), 19 (ATM)</entry>
              <entry>Yes</entry>
              <entry>ARP protocol hardware identifier ID; see 
              net/if_arp.h</entry>
            </row>
            <row>
              <entry>net.interface (string)</entry>
              <entry>example: eth0</entry>
              <entry>Yes</entry>
              <entry>Name of the network interface</entry>
            </row>
            <row>
              <entry>net.media (string)</entry>
              <entry>examples: Ethernet, Frame Relay DLCI</entry>
              <entry>Yes</entry>
              <entry>Description name of the link layer protocol</entry>
            </row>

            <row>
              <entry>net.linux.sysfs_path (string)</entry>
              <entry>example: /sys/class/net/eth0</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Sysfs path to (logical) network device object. Is
              normally NOT equal to linux.sysfs_path</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para></para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>net.ethernet.link (bool)</entry>
              <entry></entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>True iff the ethernet adaptor is connected to a
              another transceiver</entry>
            </row>
            <row>
              <entry>net.ethernet.rate (int)</entry>
              <entry>example: 100000000</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Bandwidth of connection, in bits/s</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr (string)</entry>
              <entry>example: 00:10:60:5d:8e:f4</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Textual representation of MAC address</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr_lower24 (int)</entry>
              <entry>example: 0x00001060</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Binary representation of lower 24 bits of the MAC 
              address</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr_upper24 (int)</entry>
              <entry>example: 0x005d8ef4</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Binary representation of the upper 24 bits of the MAC
              address</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect2>
  </sect1>



  <sect1 id="spec-device-info">
    <title>Specification of device info files</title>
    <para>
    The format is almost self-explanatory; here's an example

    </para>
<programlisting>

&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!-- -*- SGML -*- --&gt; 

&lt;deviceinfo version="0.2"&gt;
  &lt;device&gt;
    &lt;match key="info.bus" string="usb"&gt;
      &lt;match key="usb.vendor_id" int="0x04a9"&gt;
        &lt;match key="usb.product_id" int="0x3052"&gt;
          &lt;merge key="info.category" type="string"&gt;camera&lt;/merge&gt;
          &lt;merge key="info.capabilities" type="string"&gt;camera&lt;/merge&gt;
          &lt;merge key="info.persistent" type="bool"&gt;true&lt;/merge&gt;
        &lt;/match&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;

</programlisting>
    <para>
    This .fdi file matches a Canon Digital IXUS V (for this device
    no device or interface class is advertised), so we match the USB vendor
    and product identifers. Then we merge category and capabilities into the
    device object along with setting the persistent property, and this is 
    what it looks like after being matched
    </para>
    <para>
      <inlinegraphic fileref="hal-fdi-example1.png" format="PNG"/>
    </para>
    <para>
    It's important to emphasize that any previously property stemming
    from device detection can be overridden by a device information file.
    </para>
  </sect1>

  <sect1 id="impl"><title>HAL implementation details</title>
    <para>

      Though HAL exposes an abstract view on hardware, integrating HAL
      into an operating system is highly dependent on the kernel and
      userspace utilities. The section contain implementation notes for
      various kernels supported by HAL.

    </para>

    <sect2>
      <title>Linux 2.6 and udev</title>
      <para>

	HAL is available for for Linux 2.6 systems using udev to manage
	the device nodes. A typical installation may look like this

      </para>
      <para>
	<inlinegraphic fileref="hal-linux26.png" format="PNG"/>
      </para>
      <para>

	Note that only the callout for managing storage device is shown
	in this diagram.
	
      </para>
    </sect2>

  </sect1>


</article>
