<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- CVSID: $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<!-- THIS FILE IS AUTOGENERATED FROM hal-spec.xml.in -->

<book id="index">
  <bookinfo>
    <title>HAL @VERSION@ Specification</title>
    <releaseinfo>Version @VERSION@</releaseinfo>
    <date>July 21, 2004</date> <!-- Update this manually -->
    <authorgroup>
      <author>
	<firstname>David</firstname>
	<surname>Zeuthen</surname>
	<affiliation>
	  <address>
	    <email>david@fubar.dk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </bookinfo>
  
  <chapter id="introduction">
    <title>Introduction</title>

    <sect1>
      <title>About</title>

      <para>
	This document concerns the specification of HAL which is a
	piece of software that provides a view of the various hardware
	attached to a system. In addition to this, HAL keeps detailed
	metadata for each piece of hardware and provide hooks such
	that system- and desktop-level software can react to changes
	in the hardware configuration in order to maintain system
	policy.

      </para>
      <para>

	A piece of hardware, called a device object in HAL, is
	identified by a unique identifier and a set of key/value pairs
	referered to as <emphasis>device properties</emphasis>. Some
	properties are derived from the actual hardware, some are
	merged from <emphasis>device information files</emphasis> and
	some are related to how the device is configured. This
	document specifies the set of properties and gives them
	well-defined meaning. This enable system and desktop level
	components to make a distinction between the different device
	objects and use and configure the devices based on these
	properties.

      </para>
      <para>
	
	HAL provides an easy-to-use API through D-BUS which is an IPC
	framework that, among other things, provides a system-wide
	message-bus that allows applications to talk to one
	another. Specifically, D-BUS provides asynchronous
	notification such that HAL can notify other peers on the
	message-bus when devices are added and removed as well as when
	properties on a device changes.  

      </para>
      <para>

	The most important goal of HAL is to provide plug-and-play
	facilities for UNIX-like desktops with focus on providing a
	rich and extensible description of what the devices are.  HAL
	has no other major dependencies apart from D-BUS which, given
	sufficient infrastructure, allows it to be implemented on many
	UNIX-like systems. The major focus, initially, is systems
	running the Linux 2.6 series kernels.

      </para>

    </sect1>

    <sect1>
      <title>Document History</title>
      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Version</entry>
              <entry>Date</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0.1</entry>
              <entry>September 28, 2003</entry>
              <entry>Still important things missing. Released with version
                     0.1 of the implementation</entry>
            </row>
            <row>
              <entry>0.2</entry>
              <entry>December 22, 2003</entry>
              <entry>A major rewrite.</entry>
            </row>
            <row>
              <entry>@VERSION@</entry>
              <entry></entry>
              <entry>Current draft from CVS</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect1>

    <sect1>
      <title>Acknowledgements</title>
      <para>

      Havoc Pennington's article
      <ulink url="http://www.ometer.com/hardware.html">''Making
      Hardware Just Work''</ulink> motivated this
      work. The specification and software would not exist
      without all the useful ideas, suggestions, comments and patches
      from the 
      <ulink url="http://freedesktop.org/mailman/listinfo/xdg">Free Desktop</ulink> and
      <ulink url="http://freedesktop.org/mailman/listinfo/hal">HAL</ulink>
      mailing lists.

      </para><para>

      All trademarks mentioned belong to their respective owners.

      </para>
    </sect1>

  </chapter>

  <chapter id="overview"><title>Overview</title>

  <sect1 id="ov_halarch"><title>Architecture of HAL</title>
    <para>

      The HAL consists of a number of components as outlined in the
      diagram below. Note that this diagram is high-level and doesn't
      capture implementation details.

    </para>
    <para>
      <inlinegraphic fileref="hal-arch.png" format="PNG"/>
    </para>
    <para>

      Details on each component

      <itemizedlist>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>HAL daemon</emphasis></para><para> 

          A system-wide daemon that maintains a persistent database of
          device objects. The daemon is also responsible for merging
          information from the device information file repository and
          managing the life cycle of device objects. The HAL daemon
          also contains detection and monitoring code for
          buses (such as PCI and USB buses) and devices (such as
          networking and storage devices). The HAL daemon notifies system
          level components through callouts and session level
          components using the D-BUS interface.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>HAL agents</emphasis></para><para> 

          The term <emphasis>HAL agent</emphasis> is used to
          characterize programs that is involved in the detection and
          monitoring of devices not supported directly by the HAL
          daemon.

          </para><para>

          Any program can be a HAL agent; all it means is that the
          program communicates with the HAL daemon using a specific
          interface.  Examples of use that come to mind are prototypes
          for supporting vendor or OEM specific buses/devices,
          integration of existing device detection/monitoring
          frameworks etc.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>Applications</emphasis></para><para> 

            This represents the end consumers of the HAL and comprises
            both applications that need to search for a device, but
            also (existing) device specific libraries and/or services
            that provide operations on devices. Specifically, the
            application or device library can obtain the ''address''
            (the special device file or other details), of the device
            through HAL to interact with the device through the
            kernel as normal.

          </para><para>

            In addition, this group include desktop environments such
            as GNOME or KDE. Specifically, using HAL, desktop
            environments may include session-level daemons enforcing
            certain policies when the device database managed by the
            HAL daemon changes. Such policies may include starting a
            photo management application when a camera is plugged in,
            assisting the user in finding driver software and device
            information files for a new device, displaying link
            information about network devices, mounting removable
            storage and so on.

          </para><para>

	    Note that several desktop sessions may be active on the
	    same system; it is the responsibility of session-level
	    software to arbitrate between devices.

        </para></listitem>

	<!-- ####################################################### -->

        <listitem><para>
          <emphasis>Callouts</emphasis></para><para> 

	    Callouts are programs invoked just after the HAL daemon
	    have detected a device, but just before desktop session
	    level applications are notified through the D-BUS
	    interface. As such, callouts can be used to maintain
	    system-wide policy (that may be specific to the particular
	    OS) such as changing permissions on device nodes, updating
	    the systemwide /etc/fstab file or configuring the
	    networking subsystem.

        </para></listitem>

      </itemizedlist>
      </para>
      <para>

      The HAL uses D-BUS to provide a ''network API'' to both desktop
      applications and the aforementioned HAL agents. As D-BUS is
      designed to be language independent, potentially many languages
      / runtime systems will be able to easily access the services
      offered by HAL. The D-BUS API is detailed in
      <xref linkend="dbus-api"/>.

      </para><para>

      Note that HAL doesn't enforce any policy at all, this is left
      for desktop environments and operating systems vendors to
      implement.  However, to ensure interoperability between
      operating systems and desktop environments, recommendations and
      best practises on how to enforce policy is discussed in <xref
      linkend="enforcing-policy"/>.

    </para>
  </sect1>

  <sect1 id="ov_hal_linux26"><title>HAL on Linux 2.6</title>
    <para>

      On a Linux 2.6 system HAL is implemented as shown in the diagram
      below:

      </para>
      <para>
	<inlinegraphic fileref="hal-linux26.png" format="PNG"/>
      </para>
      <para>

      Highlights

      <itemizedlist>

        <listitem><para>
	    HAL depends on the <literal>udev</literal> and 
	    <literal>linux-hotplug</literal> packages
        </para></listitem>

        <listitem><para>
	    The diagram shows an example callout program, 
	    <literal>update-fstab.sh</literal>, that creates/destroys
	    mount points and modifies the <literal>/etc/fstab</literal>
	    file accordingly whenever storage devices are added or
	    removed.
        </para></listitem>

        <listitem><para>
	    A session-level daemon, <literal>*-volume-manager</literal>,
	    for mounting storage devices is shown. This piece of software
	    depends on a properly updated <literal>/etc/fstab</literal>
	    file and a setuid <literal>mount(1)</literal> binary that 
	    allows an unprivileged user to mount devices marked with option
	    <literal>user</literal> in the <literal>/etc/fstab</literal> file.
        </para></listitem>

        <listitem><para>
	    The <literal>update-fstab.sh</literal> and 
	    <literal>*-volume-manager</literal> programs are only
	    examples on how to enforce policy and are not part of HAL
	    proper.  An OS vendor may choose to enforce policy in a
	    different way e.g. he might want to ignore the 
	    <literal>/etc/fstab</literal> file and mount storage volumes
	    in the callout or run a daemon with sufficient privileges.
	    See <xref linkend="enforcing-policy"/> for more details.
        </para></listitem>

      </itemizedlist>

    </para>
  </sect1>


  </chapter>

  <chapter>
    <title>Device Objects</title>
      <para>

	It is important to precisely define the term HAL device
	object. It's actually a bit blurry to define in general, it
	includes what most UNIX-like systems consider first class
	objects when it comes to hardware. In particular, a device
	object should represent the smallest unit of addressable
	hardware. This means there can be a one-to-many relationship
	between a physical device and the device objects exported by
	HAL. Specifically, a multi-function printer, which appear to
	users as a single device may show up as several device
	objects; e.g. one HAL device object for each of the printing,
	scanning, fax and storage interfaces. Conversely, some devices
	may be implemented such that the HAL device object represent
	several functional interfaces. HAL is not concerned with this
	duality of either one-to-many or many-to-one relationships
	between device objects and the actual iron constituting what
	users normally understand as a single piece of hardware;
	a device object represents the smallest addressable unit.

      </para><para>

	Device objects in HAL are organised on a by-connection basis,
	e.g. for a given device object X it is possible to find the
	device object Y where X is attached to Y. This gives structure
	to the device database of HAL; it is possible to map the
	devices out in a tree. Further, software emulation devices
	exported by a kernel, such as SCSI emulation for USB Storage
	Devices, are also considered device objects in HAL. This
	implies that kernel specific bits leak into the device object
	database, however users of HAL won't notice, such device
	objects are not referenced anywhere in the device objects that
	users are interested in; they are merely used as glue.

      </para><para>

	In addition to provide information about what kind of hardware
	a device object represent (such as a PCI or USB device) and
	how to address it, HAL merges information about the functional
	interfaces the OS kernel provides in order to use the device;
	in most cases this is represented on the device object as a
	string property with the name of the special device file in
	<literal>/dev</literal>. In addition to the special device
	file, a number of other useful properties are merged. This
	means that both hardware and functional properties are on the
	same device object which is very useful for an application
	programmer. For example, an application might query HAL for
	the device object that exports the special device file
	<literal>/dev/input/mouse2</literal> and learn that this is
	provide by an USB mouse from a certain manufacturer by
	checking the properties that export the USB vendor and product
	identifiers.  See <xref linkend="device-capabilities"/> and
	<xref linkend="device-properties"/> for details.

      </para><para>

	On a formal level, a device object is comprised by

      </para>

      <itemizedlist>
        <listitem><para>

          <emphasis>UDI</emphasis></para><para> 

          This is an identifier, the Unique Device Identifer, that is
          unique for a device object - that is, no other device object
          can have the same UDI at the same time.  The UDI is computed
          using bus-specific information and it is unique across
          device insertions. It is also independent of the physical
          port or slot the device may be plugged into.

        </para></listitem>
        <listitem><para>

          <emphasis>Properties</emphasis></para><para> 

          Each device object got a set of properties which are
          key/value pairs.  The key is an ASCII string while the value
          can be one of several types

          <itemizedlist>
            <listitem><para><literal>string</literal> - 
		UTF8 string</para></listitem>
            <listitem><para><literal>int32</literal> - 
		32-bit signed integer</para></listitem>
            <listitem><para><literal>bool</literal> - 
		truth value</para></listitem>
            <listitem><para><literal>double</literal> - 
		IEEE754 double precision floating point number</para></listitem>
          </itemizedlist>

        </para></listitem>
      </itemizedlist>

      <para>
	Properties of a device object carry all the important
	information about a device object. For organisational reasons
	properties are also namespaced using ''.'' as a separator.
	
      </para><para>

	It can be useful to classify properties into three groups

      </para>
      
      <itemizedlist>

	<listitem><para>Metadata - 
	                Information about how the devices are connected with
                        respect to each other (parent/child relationships),
	                what the device is, what it does etc.
	</para></listitem>

        <listitem><para>Device specific information - 
                        vendor ID, product ID, disk serial numbers, 
	                number of buttons on a mouse, formats accepted
	                by a mp3 player and so on.</para></listitem>

        <listitem><para>Usage specific information - 
	                Network link status, special device file, 
                        mount location etc.</para></listitem>
      </itemizedlist>

      <para>

	The first category is determined by HAL, the next is merged
	from either the hardware itself or device information files
	and the last is intercepted by monitoring the operating
	system.  This specification is concerned with precisely
	defining several properties; see <xref
	linkend="device-properties"/> and onwards for more
	information.  As a complement to device properties, HAL also
	provides <emphasis>conditions</emphasis> on HAL device
	objects. Conditions are used to relay events that are
	happening on devices which are not easily expressed in
	properties. This includes events such as ''processor is
	overheating'' or ''block device unmounted''.

      </para><para>

	The fundamental idea about HAL is that all ''interesting''
	information about hardware that a desktop application needs,
	can be obtained by querying HAL. Below is a screenshot of a
	simple device manager application shipped with HAL
	called <literal>hal-device-manager</literal>.  This
	application is communicating with the HAL daemon and displays
	the tree of device objects. The shown properties are for a
	device object representing a harddisk.
      </para><para>
        <inlinegraphic fileref="hal-devices1.png" format="PNG"/>
      </para><para>

      </para>
  </chapter>

  <chapter id="device-capabilities">
     <title>Device Capabilities</title>
     <para>

       Mainstream hardware isn't very good at reporting what they are,
       they only report, at best, how to interact with them. This is a
       problem; many devices, such as MP3 players or digital still
       cameras, appear to the operating system as plain USB Mass
       Storage devices when they in fact is a lot more than just
       that. The core of the problem is that without external
       metadata, the operating system and desktop environment will
       present it to the user as just e.g. a mass storage device.

     </para><para>

       As HAL is concerned with merging of external metadata, through
       e.g. device information files, there needs to be some scheme on
       how to record what the device actually is. This is achieved by
       two textual properties, <literal>info.category</literal> and
       <literal>info.capabilities</literal>. The former describes
       <emphasis>what the device is</emphasis> (as a single
       alphanumeric keyword) and the latter describes
       <emphasis>what the device does</emphasis> (as a number of
       alphanumeric keywords separated by whitespace). The keywords
       available for use is defined in this document; we'll refer to
       them in following simply as <emphasis>capabilities</emphasis>.

     </para><para>

       HAL itself, assigns capabilities on device detection time by
       inspecting the device class (if available, it depends on the
       bus type) and looking at information from the operating system
       (most OS'es has a concept of device classes). At this time the
       category is also determined by selecting the most prominent
       capability. However, both capabilities and category can be
       overridden by either device information files or callouts. This
       gives maximum flexibility, while maintaining a base level of
       capability detection.

     </para><para>

       The idea of HAL is that existing device capability specific
       libraries (such as libghoto2), would advertise what kind of HAL
       capabilities they are able to handle. As this happens over
       time, this specification will grow to precisely define what a
       device with a given capability is supposed to do and what
       library, or service, the application programmer can use to
       access the device.
     
     </para><para>

       Having a capability also means that part of the property
       namespace, prefixed with the capability name, will be populated
       with more specific information about the capability. Indeed,
       some properties may even be required such that applications and
       device libraries have something to expect. For instance, the
       capability for being a MP3 player may require properties
       defining what audio formats the device support, whether it
       support recording of audio, and how to interact with
       device. For example, the latter may specify ''USB Storage
       Device'' or ''proprietary protocol, use libfooplayer''.

     </para><para>

       Finally, capabilities have an inheritance scheme, e.g. if a device
       has a capability <literal>foo.bar</literal>, it must also have
       the capability <literal>foo</literal>.

     </para><para>

       The following table define the capabilities exported by HAL
       at the current release:

     </para>
     <informaltable>
       <tgroup cols="2">
         <thead>
           <row>
             <entry>Capability</entry>
             <entry>Description</entry>
             <entry>Example Devices</entry>
           </row>
         </thead>
         <tbody>

           <row>
             <entry>input</entry>
             <entry>A human input device</entry>
             <entry>Keyboard, Mouse</entry>
           </row>
           <row>
             <entry>input.mouse</entry>
             <entry>A pointing device, such as a mouse</entry>
             <entry></entry>
           </row>
           <row>
             <entry>input.keyboard</entry>
             <entry>A keyboard</entry>
             <entry></entry>
           </row>

           <row>
             <entry>storage</entry>
             <entry>A storage device</entry>
             <entry>Harddisk, USB storage</entry>
           </row>
           <row>
             <entry>storage.removable</entry>
             <entry>A storage device with removable media</entry>
             <entry>CD-ROM, CR-R, Floppy, DVD, Zip-drive</entry>
           </row>

           <row>
             <entry>storage_controller</entry>
             <entry>A device for controlling storage devices</entry>
             <entry>USB storage, IDE, SCSI, RAID controller</entry>
           </row>
           <row>
             <entry>storage_controller.ide</entry>
             <entry>A device for controlling IDE storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.scsi</entry>
             <entry>A device for controlling SCSI storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.floppy</entry>
             <entry>A device for controlling floppy storage devices</entry>
             <entry></entry>
           </row>
           <row>
             <entry>storage_controller.raid</entry>
             <entry>A device for controlling RAID storage devices</entry>
             <entry></entry>
           </row>

           <row>
             <entry>bridge</entry>
             <entry>The device is bridging one bus to another</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>bridge.cardbus</entry>
             <entry>PCI to CardBus bridge</entry>
             <entry>The standard interface for PCMCIA formfactor cards</entry>
           </row>
           <row>
             <entry>bridge.pcmcia</entry>
             <entry>PCI to PCMCIA bridge</entry>
             <entry>Used in old laptops, not very common anymore</entry>
           </row>
           <row>
             <entry>bridge.pci</entry>
             <entry>PCI to PCI bridge</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>bridge.host</entry>
             <entry>PCI host bridge</entry>
             <entry>Found in many PC's today</entry>
           </row>

           <row>
             <entry>video</entry>
             <entry>Video adaptor</entry>
             <entry>Found in many PC's today</entry>
           </row>
           <row>
             <entry>video.vga</entry>
             <entry>VGA comptible video adaptor</entry>
             <entry>Almost all graphics adaptors in the market</entry>
           </row>

           <row>
             <entry>multimedia</entry>
             <entry>Multimedia device</entry>
             <entry>Sound cards etc.</entry>
           </row>
           <row>
             <entry>multimedia.audio</entry>
             <entry>Sound card</entry>
             <entry></entry>
           </row>

           <row>
             <entry>comm</entry>
             <entry>Communication adaptors</entry>
             <entry>Serial and parallel port adaptors</entry>
           </row>
           <row>
             <entry>comm.serial</entry>
             <entry>Serial port adaptor</entry>
             <entry></entry>
           </row>
           <row>
             <entry>comm.parallel</entry>
             <entry>Parallel port adaptor</entry>
             <entry></entry>
           </row>

           <row>
             <entry>modem</entry>
             <entry>A PSTN modem</entry>
             <entry></entry>
           </row>
           <row>
             <entry>modem.hayes</entry>
             <entry>A PSTN modem compatible with the Hayes command protocol</entry>
             <entry></entry>
           </row>

           <row>
             <entry>serial_controller</entry>
             <entry>Modern serial communication controllers</entry>
             <entry>USB, IEEE1394 (Firewire, i.Link)</entry>
           </row>
           <row>
             <entry>serial_controller.ieee1394</entry>
             <entry>IEEE1394 controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>serial_controller.usb</entry>
             <entry>USB controller</entry>
             <entry></entry>
           </row>


           <row>
             <entry>net</entry>
             <entry>Networking controller</entry>
             <entry>Ethernet, ATM etc. controllers</entry>
           </row>
           <row>
             <entry>net.ethernet</entry>
             <entry>Ethernet controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>net.atm</entry>
             <entry>ATM controller</entry>
             <entry></entry>
           </row>
           <row>
             <entry>net.tokenring</entry>
             <entry>Token Ring controller</entry>
             <entry></entry>
           </row>

           <row>
             <entry>printer</entry>
             <entry>Printer</entry>
             <entry></entry>
           </row>

           <row>
             <entry>hub</entry>
             <entry>A device for multiplexing a number of devices of same bus-type on a single port </entry>
             <entry>USB hub</entry>
           </row>

           <row>
             <entry>bluetooth_adaptor</entry>
             <entry>Bluetooth adaptor</entry>
             <entry></entry>
           </row>

           <row>
             <entry>block</entry>
             <entry>Device represents a block device</entry>
             <entry></entry>
           </row>

           <row>
             <entry>volume</entry>
             <entry>Device represents a partition of a block device that can 
             be mounted in the filesystem</entry>
             <entry></entry>
           </row>

           <row>
             <entry>camera</entry>
             <entry>Device is a camera where still pictures can be extracted from</entry>
             <entry></entry>
           </row>

         </tbody>
       </tgroup>
     </informaltable>
     <para>

     As evident, most of the capabilities in the above list is derived
     directly from USB and PCI classes (the careful reader will even
     note that not all classes from the USB and PCI standards are
     mentioned), and as such, are not very interesting to desktop
     applications.

     </para><para>

     However, if HAL becomes adopted by applications, new and
     interesting capabilities (for example <emphasis>pda</emphasis>,
     <emphasis>camera</emphasis> or
     <emphasis>handheld_music_player</emphasis>), based on what the
     device is used for, can begin to appear.

     </para>
  </chapter>

  <chapter id="using-devices">
    <title>Using devices</title>
    <para>

      While the HAL daemon provides generic operations that apply to
      all devices (though some may be no-ops), HAL is not concerned
      with providing non-generic device operations. Specifically, one
      goal of HAL is to integrate with existing and future libraries
      that target a specific class of devices such as cameras or mp3
      players.

    </para><para>

      For instance, libgphoto2 could be patched such that the
      application programmer can simply pass the UDI of the camera he
      wishes to interact with and libghoto2 would then, via D-BUS,
      acquire the bus-specific information required, the address so to
      speak, from the HAL daemon, and then interact directly with the
      hardware.

    </para><para>

      Another option is to use the existing API of the device library
      to discover devices (the library would be using HAL under the
      hood) and provide a function to retrieve the HAL UDI of the
      device. When the library is built without HAL support this
      function returns <literal>NULL</literal>, however, when the UDI
      is available, then applications using the library can use the
      UDI both as stable reference to the device and also to extract
      more information directly from the HAL daemon.

    </para>
  </chapter>

  <chapter id="device-properties">
    <title>Device Properties</title>

    <para>
      Properties are arranged in a namespaces using ''.'' as a separator
      and are key/value pairs. The value may assume different types; currently
      int32, double, bool and UTF8 strings are supported. The key of a property
      is always an ASCII string without any whitespace.
    </para>

    <sect1 id="device-properties-info">
      <title>info namespace</title>
      <para>
      The info namespace of the properties can be considered meta-data about
      a device. The following properties are defined:
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>info.bus (string)</entry>
              <entry>pci, usb, ide_host, ide, block, usb, usbif, scsi_host, scsi_device</entry>
              <entry>Yes</entry>
              <entry>Describes what ''physical'' bus the device is on</entry>
            </row>
            <row>
              <entry>info.udi (string)</entry>
              <entry>example: /org/freedesktop/Hal/devices/block_22_0</entry>
              <entry>Yes</entry>
              <entry>The HAL unique device id</entry>
            </row>
            <row>
              <entry>info.persistent (bool)</entry>
              <entry></entry>
              <entry>No, but required if info.not_available is set to true</entry>
              <entry>If this property is set, the device will remain in the
                     the GDL even if the device is unplugged</entry>
            </row>
            <row>
              <entry>info.not_available (bool)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>The device is currently not available (it may be unplugged
                     or powered down)</entry>
            </row>
            <row>
              <entry>info.capabilities (string)</entry>
              <entry>example: block storage storage.removable</entry>
              <entry>No</entry>
              <entry>A white-space separated list of capabilities describing what the devices does</entry>
            </row>
            <row>
              <entry>info.category (string)</entry>
              <entry>example: storage.removable</entry>
              <entry>No</entry>
              <entry>The prominent capability describing what the device is</entry>
            </row>
            <row>
              <entry>info.product (string)</entry>
              <entry>examples: SleekKeyboard, MouseMan 2003, Volume, LS-120 SLIM3 00 UHD Floppy</entry>
              <entry>No</entry>
              <entry>The name of the product or class, the device is an instance of</entry>
            </row>
            <row>
              <entry>info.vendor (string)</entry>
              <entry>example: Logitch</entry>
              <entry>No</entry>
              <entry>The name of the vendor of the device</entry>
            </row>
            <row>
              <entry>info.parent (string)</entry>
              <entry>example: /org/freedesktop/Hal/devices/ide_1_0</entry>
              <entry>Yes, for all non-root devices</entry>
              <entry>The UDI of the parent of the device, connection-wise; 
                     see screenshots of device manager</entry>
            </row>
            <row>
              <entry>info.virtual (bool)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>If available and set to true, it means that the HAL 
                     device object doesn't represent a device per se, and
                     as such should be ignored </entry>
            </row>
            <row>
              <entry>info.physical_device (string)</entry>
              <entry></entry>
              <entry>Must only be set if, and only if, info.virtual is true</entry>
              <entry>The non-virtual device that this device is created for.</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>

      <para>

      The info.parent property is very significant - for example, it's
      what allows applications to associate a volume with a
      device. Consider the following setup of devices

      </para>
      <para>
        <inlinegraphic fileref="hal-volume-to-device.png" format="PNG"/>
      </para>
      <para>

      Now, the ''CF Reader'' USB device is an ancestor to the the
      volume that has highlight. Desktop environments can detect this
      by traversing from the volume device through parents to find the
      USB device and either merge more information (such as the
      capability camera) into the USB device object or extract the
      capability (a device information file might have merged the
      capability camera) and act accordingly. Optionally, the DE can
      make the USB device persistent by setting the property
      info.persistent to true.

      </para><para>

      Indeed, this very use-case is one of the reasons that HAL tracks
      information about volumes (FIXME: HAL should, in a later version,
      directly support a property in info. that points to the actual
      device).

      </para>
    </sect1>


    <sect1 id="device-properties-linux">
      <title>linux namespace</title>
      <para>
      This namespace is used to store Linux-specific information about the
      device and is such only required on Linux.
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>linux.sysfs_path (string)</entry>
              <entry>examples: /sys/block/sda/sda1, /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0</entry>
              <entry>Yes</entry>
              <entry>A fully-qualified path into the sysfs filesystem for the
              physical device</entry>
            </row>
            <row>
              <entry>linux.sysfs_path_device (string)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Normally this property assumes the same value as 
              linux.sysfs_path, however for some devices it assumes an
              alternate location in the sysfs filesystem. It is used
              internally in HAL</entry>
            </row>
            <row>
              <entry>linux.driver (string)</entry>
              <entry>examples: agpgart-intel, yenta_cardbus, usb, hub, hid</entry>
              <entry>No</entry>
              <entry>Name of the driver bound to this device</entry>
            </row>
            <row>
              <entry>linux.sysfs_bus_id (string)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>The part of linux.sysfs_path after last /. Used 
              internally in HAL</entry>
            </row>
            <row>
              <entry>linux.kernel_devname (string)</entry>
              <entry>example: usb-0000:00:07.2-1.2</entry>
              <entry>No</entry>
              <entry>A name specifically used by the kernel to identify the
              device. Used internally in HAL</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect1>


    <sect1 id="device-properties-pci">
      <title>pci namespace</title>
      <para>
      If a device is on a PCI bus, then these properties are available:
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>pci.device_class (int)</entry>
              <entry>example: 3</entry>
              <entry>Yes</entry>
              <entry>Device class</entry>
            </row>
            <row>
              <entry>pci.device_subclass (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device subclass</entry>
            </row>
            <row>
              <entry>pci.device_protocol (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device protocol</entry>
            </row>
            <row>
              <entry>pci.product_id (int)</entry>
              <entry>example: 0x4c4d</entry>
              <entry>Yes</entry>
              <entry>Product ID</entry>
            </row>
            <row>
              <entry>pci.vendor_id (int)</entry>
              <entry>example: 0x1002</entry>
              <entry>Yes</entry>
              <entry>Vendor ID</entry>
            </row>
            <row>
              <entry>pci.subsys_product_id (int)</entry>
              <entry>example: 0x009e</entry>
              <entry>Yes</entry>
              <entry>Subsystem product id</entry>
            </row>
            <row>
              <entry>pci.subsys_vendor_id (int)</entry>
              <entry>example: 0x1028</entry>
              <entry>Yes</entry>
              <entry>Subsystem vendor id</entry>
            </row>
            <row>
              <entry>pci.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:01/0000:01:00.0</entry>
              <entry>Yes</entry>
              <entry>Equals linux.sysfs_path</entry>
            </row>
            <row>
              <entry>pci.product (string)</entry>
              <entry>Rage Mobility P/M AGP 2x</entry>
              <entry>No</entry>
              <entry>Name of the product per the PCI database</entry>
            </row>
            <row>
              <entry>pci.vendor (string)</entry>
              <entry>ATI Technologies Inc</entry>
              <entry>No</entry>
              <entry>Name of the vendor per the PCI database</entry>
            </row>
            <row>
              <entry>pci.subsys_product (string)</entry>
              <entry>Inspiron 7500</entry>
              <entry>No</entry>
              <entry>Name of the subsystem product per the PCI database</entry>
            </row>
            <row>
              <entry>pci.subsys_vendor (string)</entry>
              <entry>Dell Computer Corporation</entry>
              <entry>No</entry>
              <entry>Name of the subsystem vendor per the PCI database</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      (FIXME: Some key PCI information (bus, slot, port, function
      etc.) is missing here, but that is easy to add once someone
      request it)

      </para>
    </sect1>


    <sect1 id="device-properties-usb">
      <title>usb, usbif namespace</title>
      <para>

      If a device is on a USB bus, then these properties
      areavailable. Note that USB devices and the associated USB
      interfaces are split onto different devices (and info.bus
      values). An USB interface is always a child of the corresponding
      USB device.

      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>usb.bus_number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The USB bus the device is attached to</entry>
            </row>
            <row>
              <entry>usb.configuration_value (int) </entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The current configuration the USB device is in,
              starting from 1</entry>
            </row>
            <row>
              <entry>usb.num_configurations (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of configurations this USB device 
              can assume</entry>
            </row>
            <row>
              <entry>usb.device_class (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device class</entry>
            </row>
            <row>
              <entry>usb.device_subclass (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device sub class</entry>
            </row>
            <row>
              <entry>usb.device_protocol (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Device protocol</entry>
            </row>

            <row>
              <entry>usb.is_self_powered (bool)</entry>
              <entry>example: false</entry>
              <entry>Yes</entry>
              <entry>The device, in this configuration, is self powered</entry>
            </row>
            <row>
              <entry>usb.can_wake_up (bool)</entry>
              <entry>example: true</entry>
              <entry>Yes</entry>
              <entry>The device, in this configuration, can wake up</entry>
            </row>

            <row>
              <entry>usb.max_power (int)</entry>
              <entry>example: 98</entry>
              <entry>Yes</entry>
              <entry>Max power drain of device, in mA</entry>
            </row>
            <row>
              <entry>usb.num_interfaces (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of interfaces in current configuration</entry>
            </row>
            <row>
              <entry>usb.num_ports (int)</entry>
              <entry>example: 0</entry>
              <entry>Yes</entry>
              <entry>Number of ports on a hub. Zero for non-hubs</entry>
            </row>
            <row>
              <entry>usb.port_number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>The port number on the parent hub, starting from 1</entry>
            </row>
            <row>
              <entry>usb.speed_bcd (int)</entry>
              <entry>examples: 0x00150, 0x01200, 0x48000</entry>
              <entry>Yes</entry>
              <entry>Speed of device in BCD</entry>
            </row>
            <row>
              <entry>usb.version_bcd (int)</entry>
              <entry>examples: 0x0100, 0x0110, 0x0200</entry>
              <entry>Yes</entry>
              <entry>USB version of device in BCD</entry>
            </row>
            <row>
              <entry>usb.level_number (int)</entry>
              <entry>example: 2</entry>
              <entry>Yes</entry>
              <entry>Depth in physical USB tree, where the virtual root hub
              is at depth 0</entry>
            </row>
            <row>
              <entry>usb.linux.device_number (string)</entry>
              <entry>example: 19</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Device number assigned by the Linux kernel</entry>
            </row>
            <row>
              <entry>usb.linux.parent_number (string)</entry>
              <entry>example: 19</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Device number of parent device as assigned by the
              Linux kernel</entry>
            </row>
            <row>
              <entry>usb.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Equal to linux.sysfs_path</entry>
            </row>
            <row>
              <entry>usb.product_id (int)</entry>
              <entry>example: 0x3005</entry>
              <entry>Yes</entry>
              <entry>USB product ID</entry>
            </row>
            <row>
              <entry>usb.vendor_id (int)</entry>
              <entry>example: 0x04b3</entry>
              <entry>Yes</entry>
              <entry>USB vendor ID</entry>
            </row>
            <row>
              <entry>usb.device_revision_bcd (int)</entry>
              <entry>example: 0x0100</entry>
              <entry>Yes</entry>
              <entry>Revision number of device, in BCD</entry>
            </row>
            <row>
              <entry>usb.serial (string)</entry>
              <entry></entry>
              <entry>No</entry>
              <entry>A string uniquely identifying the instance 
              of the device; ie. it will be different for two, otherwise
              identical devices</entry>
            </row>
            <row>
              <entry>usb.product (string)</entry>
              <entry>example: IBM USB HUB KEYBOARD</entry>
              <entry>No</entry>
              <entry>Name of the product per the USB database</entry>
            </row>
            <row>
              <entry>usb.vendor (string)</entry>
              <entry>example: IBM Corp.</entry>
              <entry>No</entry>
              <entry>Name of the vendor per the USB database</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      And these are the properties for an USB interface

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>usbif.device_product_id (int)</entry>
              <entry>example: 0x3005</entry>
              <entry>Yes</entry>
              <entry>USB product ID of the device this interface
              belongs to</entry>
            </row>
            <row>
              <entry>usbif.device_vendor_id (int)</entry>
              <entry>example: 0x04b3</entry>
              <entry>Yes</entry>
              <entry>USB vendor ID of the device this interface
              belongs to</entry>
            </row>
            <row>
              <entry>usbif.interface_class (int)</entry>
              <entry>example: 0x03</entry>
              <entry>Yes</entry>
              <entry>Class of this interface</entry>
            </row>
            <row>
              <entry>usbif.interface_subclass (int)</entry>
              <entry>example: 0x01</entry>
              <entry>Yes</entry>
              <entry>Subclass of this interface</entry>
            </row>
            <row>
              <entry>usbif.interface_protocol (int)</entry>
              <entry>example: 0x01</entry>
              <entry>Yes</entry>
              <entry>Protocol for this interface</entry>
            </row>
            <row>
              <entry>usbif.number (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Number of this interface</entry>
            </row>
            <row>
              <entry>usbif.linux.sysfs_path (string)</entry>
              <entry>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1/1-1.1:1.0</entry>
              <entry>Yes</entry>
              <entry>Equals linux.sysfs_path</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect1>


    <sect1 id="device-properties-ide">
      <title>ide, ide_host namespace</title>
      <para>

      These namespaces are used to characterise IDE host adaptors and IDE
      channels. In a standard PC, there are usually two IDE host
      adaptors each with two channels (master and slave). Normally, the
      device chain looks like
     
      </para> 
      <programlisting>
      storage_controller.ide -&gt; ide_host -&gt; ide -&gt; block -&gt; block
      </programlisting>
      <para>

      where the first device represents the IDE controller on the motherboard
      while the last device represents a partition on a (slave or master) 
      IDE disk, and the device before that represent, e.g. a physical
      harddisk. Notably, the first block device will have capability storage
      (maybe even storage.removable) and the last block device will have
      capability volume.

      </para><para>

      (FIXME: Is this the right terminology to use?)

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ide_host.number (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>A unique number identifying the IDE host adaptor</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>

      </para>
      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ide.channel (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Corresponds to ide_host.number of the ide_host device
              that is the parent of this device</entry>
            </row>
            <row>
              <entry>ide.sub_channel (int)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>Identifies the IDE channel of this interface</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>

      </para>
    </sect1>

    <sect1 id="device-properties-scsi">
      <title>scsi_host, scsi_device namespace</title>
      <para>
      (FIXME: Need to populate these namespaces with some interesting
      information such as SCSI LUN address and so on.)
      </para>
    </sect1>

    <sect1 id="device-properties-input">
      <title>input namespace</title>
      <para>
      
      This namespace is concerned with input devices such as
      keyboards, pointing devices and game controllers.  If a device
      has the capability input (USB HID devices normally do), then the
      folling properties are available
      
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>input.absolute (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device is capable of giving absolute device
              coordinates when motion is detected (such as a tablet or
              game controller)</entry>
            </row>
            <row>
              <entry>input.absolute.x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.z (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rx (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.ry (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rz (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rz (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.throttle (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.rudder (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.wheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.gas (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.brake (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat0x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat0y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat1x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat1y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat2x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.hat2y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.pressure (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.distance (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.tilt_x (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.tilt_y (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.absolute.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.absolute is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.relative (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device is capable of giving relate device
              coordinates when motion is detected (such as a mouse)</entry>
            </row>
            <row>
              <entry>input.relative.x (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.y (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.z (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.hwheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.dial (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.wheel (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.relative.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.relative is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.led (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device has LED indicators that can be on or off
              </entry>
            </row>
            <row>
              <entry>input.led.numlock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.capslock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.scrolllock (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.compose (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.kana (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.sleep (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.suspend (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.mute (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.misc (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>
            <row>
              <entry>input.led.max (bool)</entry>
              <entry></entry>
              <entry>Only if input.led is true</entry>
              <entry>WRITEME</entry>
            </row>

            <row>
              <entry>input.force_feedback (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry></entry>
            </row>

            <row>
              <entry>input.key (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device has keys the user can press</entry>
            </row>
            <row>
              <entry>input.repeat (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device sends repeat keypresses if a key is pressed
              down</entry>
            </row>
            <row>
              <entry>input.sound (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>The device can emit sounds</entry>
            </row>

            <row>
              <entry>input.linux.phys (string)</entry>
              <entry>example: usb-0000:00:07.2-1.2</entry>
              <entry>Yes (Linux only)</entry>
              <entry>The name of the physical device as used by the kernel.
              Used internally by HAL; see also linux.kernel_devname</entry>
            </row>

            <row>
              <entry>input.linux.handlers (string)</entry>
              <entry>examples: mouse1, kbd</entry>
              <entry>Yes (Linux only)</entry>
              <entry>The Linux input handlers for this device</entry>
            </row>
            <row>
              <entry>input.linux.keybit (string)</entry>
              <entry>examples: 10000 7f ffe7207a c14057ff ffbeffdf ffffffff ffffffff fffffffe, f0000 0 0 0 0 0 0 0 0</entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>

            <row>
              <entry>input.linux.evbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.ledbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.relbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>
            <row>
              <entry>input.linux.absbit (int)</entry>
              <entry></entry>
              <entry>Yes (Linux only)</entry>
              <entry>From device descriptor in the input subsystem (see 
              kernel source)</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      (FIXME: Is this too linux specific?)

      </para>
    </sect1>


    <sect1 id="device-properties-block">
      <title>block namespace</title>
      <para>

      A block device is either a storage device (such as a harddisk, floppy
      or optical driver) or a partition on a storage, ie. a volume.

      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>block.block_size (int)</entry>
              <entry>example: 512</entry>
              <entry>Yes</entry>
              <entry>Size in octects of every block on the device</entry>
            </row>
            <row>
              <entry>block.size (int)</entry>
              <entry>example: 15584</entry>
              <entry>Yes</entry>
              <entry>Size of storage area, in blocks</entry>
            </row>
            <row>
              <entry>block.start (int)</entry>
              <entry>example: 32</entry>
              <entry>Yes</entry>
              <entry>Linear offset, in blocks, where the storage area
              starts</entry>
            </row>
            <row>
              <entry>block.major (int)</entry>
              <entry>example: 8</entry>
              <entry>Yes</entry>
              <entry>Major number of special file to interact with the 
              device</entry>
            </row>
            <row>
              <entry>block.minor (int)</entry>
              <entry>example: 1</entry>
              <entry>Yes</entry>
              <entry>Minor number of special file to interact with the 
              device</entry>
            </row>
            <row>
              <entry>block.is_volume (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>True iff the block device is a volume that can be mounted 
              into the file system</entry>
            </row>
            <row>
              <entry>block.is_mounted (bool)</entry>
              <entry></entry>
              <entry>Yes</entry>
              <entry>True iff the block device is currently mounted in the
              file system</entry>
            </row>

            <row>
              <entry>block.device (string)</entry>
              <entry>example: /udev/sda1 </entry>
              <entry>Mandatory if block.is_volume is true</entry>
              <entry></entry>
            </row>

            <row>
              <entry>block.fs_type (string)</entry>
              <entry>example: vfat </entry>
              <entry>Mandatory if block.is_mounted is true</entry>
              <entry></entry>
            </row>
            <row>
              <entry>block.mount_point (string)</entry>
              <entry>example: /mnt/cfreader </entry>
              <entry>Mandatory if block.is_mounted is true</entry>
              <entry></entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>

      blabla

      </para>
    </sect1>


    <sect1 id="device-properties-net">
      <title>net, net.ethernet namespace</title>
      <para>
      The net and net.ethernet namespace contains information about
      (logicial) network devices and only applies to devices with
      capability net and/or net.ethernet.
      </para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>net.arp_proto_hw_id (int)</entry>
              <entry>examples: 1 (ethernet), 19 (ATM)</entry>
              <entry>Yes</entry>
              <entry>ARP protocol hardware identifier ID; see 
              net/if_arp.h</entry>
            </row>
            <row>
              <entry>net.interface (string)</entry>
              <entry>example: eth0</entry>
              <entry>Yes</entry>
              <entry>Name of the network interface</entry>
            </row>
            <row>
              <entry>net.media (string)</entry>
              <entry>examples: Ethernet, Frame Relay DLCI</entry>
              <entry>Yes</entry>
              <entry>Description name of the link layer protocol</entry>
            </row>

            <row>
              <entry>net.linux.sysfs_path (string)</entry>
              <entry>example: /sys/class/net/eth0</entry>
              <entry>Yes (only on Linux)</entry>
              <entry>Sysfs path to (logical) network device object. Is
              normally NOT equal to linux.sysfs_path</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para></para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Key (type)</entry>
              <entry>Values</entry>
              <entry>Mandatory</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>

            <row>
              <entry>net.ethernet.link (bool)</entry>
              <entry></entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>True iff the ethernet adaptor is connected to a
              another transceiver</entry>
            </row>
            <row>
              <entry>net.ethernet.rate (int)</entry>
              <entry>example: 100000000</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Bandwidth of connection, in bits/s</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr (string)</entry>
              <entry>example: 00:10:60:5d:8e:f4</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Textual representation of MAC address</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr_lower24 (int)</entry>
              <entry>example: 0x00001060</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Binary representation of lower 24 bits of the MAC 
              address</entry>
            </row>
            <row>
              <entry>net.ethernet.mac_addr_upper24 (int)</entry>
              <entry>example: 0x005d8ef4</entry>
              <entry>Only if net.arp_proto_hw_id=1</entry>
              <entry>Binary representation of the upper 24 bits of the MAC
              address</entry>
            </row>

          </tbody>
        </tgroup>
      </informaltable>
      <para>
      </para>
    </sect1>
  </chapter>

  <chapter id="spec-device-info">
    <title>Device Information Files</title>
    <para>
    The format is almost self-explanatory; here's an example

    </para>
<programlisting>

&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!-- -*- SGML -*- --&gt; 

&lt;deviceinfo version="0.2"&gt;
  &lt;device&gt;
    &lt;match key="info.bus" string="usb"&gt;
      &lt;match key="usb.vendor_id" int="0x04a9"&gt;
        &lt;match key="usb.product_id" int="0x3052"&gt;
          &lt;merge key="info.category" type="string"&gt;camera&lt;/merge&gt;
          &lt;merge key="info.capabilities" type="string"&gt;camera&lt;/merge&gt;
          &lt;merge key="info.persistent" type="bool"&gt;true&lt;/merge&gt;
        &lt;/match&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;

</programlisting>
    <para>
    This .fdi file matches a Canon Digital IXUS V (for this device
    no device or interface class is advertised), so we match the USB vendor
    and product identifers. Then we merge category and capabilities into the
    device object along with setting the persistent property, and this is 
    what it looks like after being matched
    </para>
    <para>
      <inlinegraphic fileref="hal-fdi-example1.png" format="PNG"/>
    </para>
    <para>
    It's important to emphasize that any previously property stemming
    from device detection can be overridden by a device information file.
    </para>
  </chapter>

  <chapter id="dbus-api">
    <title>D-BUS Network API</title> <para> 

      The HAL daemon is a system-wide process that keeps track of a
      number of device objects. It communicates with the operating
      system and intercepts hotplug events as devices are plugged in
      and removed.  The daemon is also responsible for providing
      services to applications that wants to locate devices and
      perform generic operations them such as obtaining exclusive
      access.  Non-generic operations, such as obtaining pictures from
      a camera device, is outside the scope of the HAL daemon; see
      <xref linkend="using-devices"/> for more information.

      </para><para>

      HAL has the concept of device stores. When a device is detected
      it is placed in the TDL (temporary device list) and then properties
      are merged from several sources including device information files
      and possibly callouts. Eventually, the device transitions to the
      GDL (global device list) and first then it becomes ''visible'' for 
      desktop applications.

      </para>

      <sect1><title>Interface org.freedesktop.Hal.Manager</title>

      <para> 

      Using D-BUS terminology, the HAL daemon provides the D-BUS
      service <literal>org.freedesktop.Hal</literal>. This service
      offers a D-BUS object at a well-known
      location <literal>/org/freedesktop/Hal/Manager</literal>. This
      object offers a D-BUS
      interface, <literal>org.freedesktop.Hal.Manager</literal>, for
      querying device objects with the following methods:
      </para>

<programlisting>
# Return a list of all devices in the GDL
#
# @return                       List of UDI's
#
array{string} GetAllDevices()

# Determine if a device with a given Unique Device Id exists in the GDL
#
# @param  udi                   Device UDI, for example '/org/freedesktop/Hal/devices/pci_8086_7111'
# @return                       TRUE iff the device with the given UDI exists
#
bool DeviceExists(string udi)

# Find the set of devices in the GDL that has a given property matching
# a given value
#
# @param  key                   Key, for example 'block.fstype'
# @param  value                 Value, for example 'ext3'
# @return                       Array of UDI's, may be empty
#
array{string} FindDeviceStringMatch(string key, string value)

# Find the set of devices in the GDL that has a given capability
#
# @param  capability            Capability, for example 'volume'
# @return                       Array of UDI's, may be empty
#
array{string} FindDeviceByCapability(string capability)
  
</programlisting>

      <para>

      This object also emits the following signals on the
      <literal>/org/freedesktop/Hal/Manager</literal> object on the
      <literal>org.freedesktop.Hal.Manager</literal> interface that
      applications can subscribe to using D-BUS:

      </para>

<programlisting>

# Notification that a new device have been added to the GDL
#
# @param  udi                   Unique Device Id
#
void DeviceAdded(string udi)

# Notification that a new device have been removed from the GDL. The
# application cannot use this UDI anymore.
#
# @param  udi                   Unique Device Id
#
void DeviceRemoved(string udi)

# Notification that a device in the GDL have got a new capability. Note that
# this is emitted even though the device already had the old capability
#
# @param  udi                   Unique Device Id
#
void NewCapability(string udi, string capability)

</programlisting>


      <sect2><title>Example</title>

      <para>

      The following brief Python program demonstrates some of the API

      </para>

<programlisting>
  <inlinegraphic format="linespecific" fileref="examply-manager.py"/>
</programlisting>

      <para>

      which gives the following output

      </para>

<programlisting>
Found device /org/freedesktop/Hal/devices/block_TORiSAN DVD-ROM DRD-U624-00000000000000000001-disc
Found device /org/freedesktop/Hal/devices/block_TORiSAN DVD-ROM DRD-U624-00000000000000000001
Found device /org/freedesktop/Hal/devices/block_37332a77-105e-4e76-8e99-27d3746e0531
Found device /org/freedesktop/Hal/devices/block_3_2
Found device /org/freedesktop/Hal/devices/block_LS-120 SLIM3 00 UHD Floppy-0208MBA00211
Found device /org/freedesktop/Hal/devices/block_IC25N020ATCS05-0-CLP225F2G3UR4A
Found device /org/freedesktop/Hal/devices/ide_1_1
Found device /org/freedesktop/Hal/devices/ide_0_0
Found device /org/freedesktop/Hal/devices/ide_1_0
Found device /org/freedesktop/Hal/devices/usbif_usb_0_0_206_-1_0000:00:07.2_0
Found device /org/freedesktop/Hal/devices/ide_host_0
Found device /org/freedesktop/Hal/devices/ide_host_1
Found device /org/freedesktop/Hal/devices/pci_104c_8400
Found device /org/freedesktop/Hal/devices/usb_0_0_206_-1_0000:00:07.2
Found device /org/freedesktop/Hal/devices/pci_1002_4c4d
Found device /org/freedesktop/Hal/devices/pci_125d_1978
Found device /org/freedesktop/Hal/devices/pci_8086_7111
Found device /org/freedesktop/Hal/devices/pci_104c_ac1c/0
Found device /org/freedesktop/Hal/devices/pci_8086_7112
Found device /org/freedesktop/Hal/devices/pci_8086_7110
Found device /org/freedesktop/Hal/devices/input_13_65
Found device /org/freedesktop/Hal/devices/pci_104c_ac1c
Found device /org/freedesktop/Hal/devices/pci_8086_7190
Found device /org/freedesktop/Hal/devices/input_13_64
Found device /org/freedesktop/Hal/devices/pci_8086_7113
Found device /org/freedesktop/Hal/devices/pci_8086_7191
Found device /org/freedesktop/Hal/devices/computer

(insert USB mouse)

Device /org/freedesktop/Hal/devices/usb_46d_c001_410_-1_noserial was added
Device /org/freedesktop/Hal/devices/usbif_usb_46d_c001_410_-1_noserial_0 was added

(remove USB mouse)

Device /org/freedesktop/Hal/devices/usb_46d_c001_410_-1_noserial was removed
Device /org/freedesktop/Hal/devices/usbif_usb_46d_c001_410_-1_noserial_0 was removed
</programlisting>

      <para>

      </para>

      </sect2>

      </sect1>

      <sect1><title>Interface org.freedesktop.Hal.Device</title><para>

      Applications use
      the <literal>org.freedesktop.Hal.Manager</literal> interface to
      locate the device objects they are interested in. When a device
      object (which is really a D-BUS object, note that the UDI is the
      objects object_path) is obtained, the HAL daemon provides the
      <literal>org.freedesktop.Hal.Device</literal> interface on the
      object denoted by the UDI. This interface has the following
      methods

      </para>

<programlisting>

# Set property
#
# @param  key                   Property to set
# @param  value                 Value to set
# @raises                       org.freedesktop.Hal.(NoSuchDevice|TypeMismatch)
#
void SetProperty(string key, any value)
void SetPropertyString(string key, string value)
void SetPropertyInteger(string key, int32 value)
void SetPropertyBoolean(string key, bool value)
void SetPropertyDouble(string key, double value)

# Get property
#
# @param  key                   Property to get
# @return                       The value of the property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty|TypeMismatch)
#
any GetProperty(string key)
string GetPropertyString(string key)
int32 GetPropertyInteger(string key)
bool GetPropertyBoolean(string key)
double GetPropertyDouble(string key)

# Get all properties
#
# @return                       Dictionary from key to value
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
map{string, any} GetAllProperties()

  
# Remove a property
#
# @param  key                   Property to remove
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty)
#
void RemoveProperty(string key)

# Get the type of a property
#
# @param  key                   Property
# @return                       D-BUS type of property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty)
#
int32 GetPropertyType(string key)

# Determine if a property exists
#
# @param  key                   Property
# @return                       TRUE iff the property exists
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool PropertyExists(string key)

# Add a capability to a device. Note that this will trigger a NewCapability
# signal to all client applications subscribing to signals from the Manager
# interface.
#
# @param  capability            Capability, e.g. 'net.80211'
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void AddCapability(string capability)

# Determine if a device got a given capability
#
# @param  capability            Capability, e.g. 'storage.cdrom'
# @return                       TRUE iff the device got the given capability
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool QueryCapability(string capability)
</programlisting>

      <para>

      The device objects also emits the following signals on the
      org.freedesktop.Hal interface that applications can subscribe to 
      using D-BUS

      </para>
<programlisting>
# Notification that property have been modified
#
# @param  key                   Property
# @param  added                 True iff the property have been added
# @param  removed               True iff the property have been removed
#
void PropertyModified(string key, bool added, bool removed)

# Notification that an event happened on the device has occured.
#
# Normally this is used to signal events that aren't or can't be expressed
# in properties, e.g. 'ProcessorOverheating' etc. 
#
# @param  condition             Name of condition
# @param  ...                   Dependent on the condition name
void Condition(string condition, ...)

</programlisting>
      <para>

      Note that D-BUS supports that applications can opt to receive
      signals for only a subset of the devices available.

      </para>

      </sect1>

      <sect1><title>Interface org.freedesktop.Hal.AgentManager</title><para>

      The API described above is available to all applications. There is 
      an additional D-BUS interface on the /org/freedesktop/Hal/Manager
      object called org.freedesktop.Hal.AgentManager which is only available
      for processes running with administrative privileges. 
      </para>

<programlisting>

# Create a new device object not in the GDL (ie. hidden from 
# applications). This object can be obtained using the given UDI as
# as the D-BUS object reference. 
#
# The object implements the org.freedesktop.Hal.Device interface
#
# @return                       Temporary UDI for new device object
#
string NewDevice()

# When a device have been built, an application can add it to the GDL.
#
# A side-effect of this call, is that the Manager object will emit the
# signal DeviceAdded.
# 
# @param  tempUdi               Temporary UDI as obtained from the NewDevice call
# @param  newUdi                New UDI to use.
# @raises                       org.freedesktop.Hal.(NoSuchDevice|UdiInUse)
#
void CommitToGDL(string tempUdi, string newUdi)

# Remove a device object. 
#
# Depending on the info.persistent property, the device may not be removed but
# rather acquire the property info.not_available with value true.
#
# @param  udi                   UDI of device
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void Remove(string udi)

# Merge all properties from one device to another device.
#
# If the source device got any capabilities, then the target device
# will acquire these capabilities and a NewCapability signal will be
# emitted for the target device for every capability in the source
# device.
#
# @param  targetUdi             UDI of device to receive properties
# @param  sourceUdi             UDI of device to copy properties from
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
void MergeProperties(string targetUdi, string sourceUdi)

# Checks that all properties where keys, starting with a given value
# (namespace), of the first device is present in the second device and that
# they got the same value and type. 
#
# Note that the other inclusion isn't tested, so there could be
# properties (from the given namespace) in the second device not present
# in the first device.
#
# @param  udi1                  UDI of device 1
# @param  udi2                  UDI of device 2
# @param  namespace             Namespace used for matching, e.g. 'usb'
# @return                       TRUE if, and only if, all properties starting
#                               with the namespace parameter from udi1 is
#                               in udi2 and assume the same value
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool DeviceMatches(string udi1, string udi2, string namespace)

</programlisting>
      <para>
      HAL Agents uses the org.freedesktop.Hal.AgentManager API when 
      discovering devices either through detection, handling hotplug
      events or through some other way.
      </para>

      </sect1>

  </chapter>


  <chapter id="enforcing-policy">
    <title>Enforcing Policy</title>
    <para> 
      blabla
    </para>
  </chapter>

</book>
